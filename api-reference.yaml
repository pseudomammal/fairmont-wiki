- title: Core
  module: fairmont-core
  description: >-
    The core functions provide the functional programming glue for JavaScript. Includes support for currying, partial application, and composition of functions.

  content:

    - title: ~
      description: ~
      content:

      - title: noOp
        signature:
          taking: any…
          returning: undefined
        description: >-
          Does nothing. Mostly useful with combinators to express the
          equivalent of an empty `return` statement.
        examples:
          code: |-
            assert.equal undefined, noOp true

      - title: identity
        signature:
          taking: any
          returning: any
        description: >-
          Returns the value given. Mostly useful with transformative
          combinators (like `map`) when you want to leave a value unchanged.
        examples:
          code: |-
            assert.equal 7, identity 7

      - title: wrap
        signature:
          taking: any
          returning: function
        description: >-
          Returns a function that always returns the given value.
        examples:
          code: |-
            f = wrap 7
            assert.equal 7, f()

      - title: curry
        signature:
          taking: function
          returning: function
        description: >-
          Convert a function taking N arguments into a function that:
            - given M < N arguments, returns another (curried) function
              taking N - M arguments
            - given N arguments, runs the given function
        examples:
          code: |-
            multiply = curry (x, y) -> x * y
            double = multiply 2
            assert.equal 8, double 4

      - title: _
        description: >-
          Special value to allow for late-binding of arguments to functions.
          See [substitute](#substitute) and [partial](#partial)

      - title: substitute
        signature:
            taking: array, array
            returning: array
        description: >-
          Given two arrays, substitute values from the second array for elements in the first array that have the special value `_`.
        examples:
          code: |-
            assert.deepEqual [1, 2, 3], substitute [1, _, 3], [2]

      - title: partial
        signature:
          taking: function, any…
          returning: function
        description: >-
          Take a function and an argument list and return another function that takes its arguments and substiutes them into the argument list (see [substitute](#substitute)).
        examples:
          code: |-
            {pow} = Math
            square = partial pow, _, 2
            assert.equal 9, square 3

      - title: flip
        signature:
          taking: function
          returning: function
        description: >-
          Flip the arguments of the given function.
        examples:
          code: |-
            pow = curry flip Math.pow
            square =  pow 2
            assert.equal 9, square 3

      - title: compose
        signature:
          taking: function…
          returning: function
        description: >-
          Compose a list of functions, returning a new function.

          You can compose functions returning promises
          and the resulting function will, in turn, return a promise.
        examples:
          - title: Inverse Square
            description: Take the inverse square of a number.
            code: |-
              inverse = (x) -> 1/x
              square = (x) -> x * x
              inverseSquare = compose inverse, square
              assert.equal 1/25, inverseSquare 5
          - title: Hash A File
            description: Take the MD5 hash of a file.
            code: |-
              hashFile = compose md5, read
              hash = yield hashFile "README.md"

      - title: pipe
        signature:
          taking: function… | array
          returning: function
        description: >-
          Compose a list or array of functions, in reverse order,
          returning a new function.

          `pipe` composes functions in order of application.
          You can also pass in an array, which is useful for
          creating “pipeline” functions.
        examples:
          code: |-
            renderFile = pipe [
              read
              parse
              render
            ]

      - title: apply
        signature:
          taking: function, any…
          returning: any
        description: >-
          Call a function with the given arguments.
        # TODO: use a more interesting example here.
        examples:
          code: |-
            arrayOfFunctions = map wrap, [1..5]
            assert.deepEqual [1..5],
              map apply, arrayOfFunctions

      - title: spread
        signature:
          taking: function
          returning: function
        description: >-
          Converts a function taking a list of arguments into a function
          taking an array.
        # TODO: use a more interesting example here.
        examples:
          code: |-
            product = spread (first, rest...) ->
              if empty rest then first else first * product rest
            assert.equal 120, product [1..5]

      - title: 'unary, binary, and ternary'
        description: >-
          Take a given function taking a variable number of arguments and
          return one taking 1, 2, or 3 arguments. Useful in conjuction with
          `curry`.
        examples:
          code: |-
            f = -> a + b
            g = curry binary f
            a = g "a"
            assert (a "b") == "ab"

      - title: negate
        description: >-
          Take a given function and return a new function that passes its
          arguments to the given function and negates the return value.
        examples:
          code: |-
            _false = -> false
            _true = negate _false
            assert _true()

- title: Multi-Methods
  description: |

    [Multi-methods][mm-1] are polymorphic functions on their arguments.
    Methods in JavaScript objects dispatch based only on the
    (implicit first argument, which is the) object itself.
    Multi-methods provide a more functional and flexible approach.

    Fairmont's multi-method dispatch is based on a predicate provided
    for each argument.
    The first implementation for which each of the predicates
    returns true, when given the corresponding argument, is chosen.

    Variadic functions can be handled by passing a variadic predicate
    (that is, a function whose length is 0),
    which will be passed the remaining arguments.
    Any predicates following a variadic predicate will fail.

    Method definitions are considered based on the order
    in which they were declared.
    The last definition is considered first.
    The first definition is considered last.
    More general definitions should thus be defined first
    and specializations later.

    [mm-1]:https://en.wikipedia.org/wiki/Multiple_dispatch

  content:
  - title: Method
    description: ''
    content:
    - title: create
      description: >-
        The `create` function defines a new multimethod, taking an optional
        description of the method. This can be accessed via the
        `description` property of the method.
      examples:
        code: >-
          Method.create multiply, description: "Multiply two values
          together"
    - title: define
      description: >-
        The `define` function adds an entry into the dispatch table. It
        takes the method, the signature, and the definition (implementation)
        as arguments.
      examples:
        code: >-
          Method.define multiply, isNumber, isNumber, (x,y) -> x * y

          Method.define multiply, isArray, isNumber, (v, n) -> n * v for x
          in v
    - title: lookup
      description: >-
        The 'lookup' function calls the 'dispatch' function, which is
        described above. This allows you to select a function without
        invoking it.
      examples:
        code: |-
          f = Method.lookup multiply, [7, 5]
          assert (f 7, 5) == 35

- title: Reactive
  module: fairmont-reactive
  description: >-
    Reactive programming functions provide support for reactive programming based on JavaScript iterators, generators, and promises.

  content:

  - title: Iterators
    description: >-
      Iterators are [defined in ES6][]:

      > An object is an iterator when it knows how to access items from a collection one at a time, while keeping track of its current position within that sequence. In JavaScript an iterator is an object that provides a next() method which returns the next item in the sequence. This method returns an object with two properties: done and value.

      In Fairmont, we refer to such an object, in general, as a _product_.

      [defined in ES6]:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators

    content:

      - title: isIterable
        description: >-
          Predicate that returns true if the argument is iterable. That is, if it has a `Symbol.iterator` property or is a generator function.
        taking: "`any`"
        returning: "`boolean`"
        examples: |-
          assert.equal true, isIterable [1..5]

      - title: isIterator
        description: >-
          A predicate that returns true if the argument is an iterator.

          Iterators are iterable (that is, they have a `Symbol.iterator`
          property) and also have a `next` property whose value is a function.
        examples:
          code: 'assert isIterator iterator [1..5]'
      - title: iterator
        description: >-
          The `iterator` function takes a given value and attempts to return
          an iterator using the value.

          If the value is an iterable, we simply call the function returned by
          the `Symbol.iterator` property.

          If the value is a already an iterator, we simply return it.

          If the value is a generator, we call the generator.

          If the value is a function, we assign it's `Symbol.iterator` and
          `next` properties to itself, and return it. (This makes it possible
          to convert arbitrary functions into iterators, too.)
        examples:
          code: |-
            i = iterator [1..5]
            assert 1 == value next i
            assert 2 == value next i
            assert 3 == value next i
            assert 4 == value next i
            assert 5 == value next i
            assert isDone next i
      - title: next
        description: >-
          Given an iterator or reactor, return a product. Equivalent to
          calling `i.next()` for a given iterator `i`.
      - title: value
        description: >-
          Returns the `value` property from a product. Equivalent to calling
          `x.value` for a given object `x`.
      - title: isDone
        description: >-
          Returns the `done` property from a product. Equivalent to calling
          `x.done` for a given object `x`.

  - title: Reactors

    description: >-
      Reactors are Fairmont's term for asynchronous iterators.

      Asynchronous iterators are an ES7 proposal.

      Instead of returning products, asynchronous iterators (reactors) return
      Promises that resolve to products (objects with `done` and `value`
      properties).

    content:

    - title: isReagent
      description: >-
        Analogous to `isIterable`.

        A predicate that returns true if its operand is an asynchronous
        iterator.

        Specifically, returns true if the `Symbol.asyncIterator` property is
        defined and is a function.

        Since reactors are based on an ES7 proposal, there are no built-in
        types that are asynchronous iterables. Fairmont provides a variety
        of functions for adapting values to reactors. See `reactor`.

      examples:
        description: >-
          In this example, `events` is a function that takes an event
          producer and returns a reactor whose products are the given event.
          See [`events`](#events).
        code: |-
          button[Symbol.asyncIterator] = -> events "click", button
          assert isReagent button

    - title: isReactor
      description: >-
        Analogous to `isIterator`.

        A predicate that returns true if its operand is a reactor.

        Reactors are reagents (that is, they have a `Symbol.asyncIterator`
        property) and also have a `next` property whose value is a function.
      examples:
        description: >-
          In this example, `events` is a function that takes an event
          producer and returns a reactor whose products are the given event.
          See [`events`](#events).
        code: |-
          r = (events "click", button)
          assert isReactor r

    - title: reactor
      description: >-
        Analogous to `iterator`. The `reactor` function takes a given value
        and attempts to return an reactor using the value.

        If the value is a reagent, we simply call the function returned by
        the `Symbol.asyncIterator` property.

        If the value is already a reactor, we simply return it.

        If the value is a function, we assign its `Symbol.asyncIterator` and
        `next` properties to itself, and return it. (This makes it possible
        to convert arbitrary functions into reactors, too.)

        If you want to use a generator function as an semi-coroutine, simply
        pass it in via the [`async`](#async) helper function to convert it
        into a promise-returning function, and then call `reactor` with the
        resulting function.
      examples:
        description: >-
          In this example, `events` is a function that takes an event
          producer and returns a reactor whose products are the given event.
          See [`events`](#events).
        code: |-
          button[Symbol.asyncIterator] = -> events "click", button
          r = reactor button
          assert isReactor r

  - title: Observers
    description: >-
      Observer functions provide a way to asynchronously observe changes to
      values. The observer receives a temporally ordered sequence of
      notifications based on changes to the observed value.
    content:

      - title: observe
        description: >-
          Given an object or an array value, returns an event emitter that
          generates events when the value is changed.
        examples:
          code: |-
            x = value: 7
            events = observe x
            events.on "change", (x) -> y = x.value
            x.value = 3
            assert y == 3

  - title: Adapters
    description: >-
      Adapters are functions that create iterators or reactors (aka,
      producers) from an existing value, like an Array or an event emitter.
    content:

      - title: producer
        description: >-
          Given a producible (that is, an iterable or reagent), or a Promise
          that resolves into a producible, returns a corresponding producer.
          Idempotent: if the operand is a already producer, it is simply
          returned.
        examples:
          code: |-
            i = producer [1..5]
            assert (value next i) == 1

      - title: pull
        description: >-
          Given an iterator whose product values are Promises, returns a
          reactor. This is useful if an iterator is used in combination with
          an asynchronous function.
        examples:
          description: >-
            Let's suppose we want a function that will convert an iterator
            that produces pathnames into a reactor producing hashes for the
            contents of the corresponding files. We might implement it like
            this.
          code: |-
            hashFiles = (pathnames) ->
              flow [
                pathnames
                map (pathname) -> read pathname
                map (promise) ->
                  promise.then (content) -> md5 content
              ]

      - title: combine
        description: >-
          Given two or more producers, combines them into a single producer
          whose products are those of the given producers in aggregate.
        examples:
          description: >-
            In the example below, `updates` is an array of reactors producing
            update functions, perhaps in response to `change` events for
            fields of a form.
          code: |-
            go [
              combine updates...
              map (update) -> update data
            ]

      - title: repeat
        description: >-
          Given a value, returns an iterator that always produces that value.
          Analogous to `wrap`for an iterator.
        examples:
          code: |-
            alwaysTrue = repeat true
            assert alwaysTrue.next()

      - title: events
        description: >-
          Given an event name and an event emitter, returns a reactor whose
          products are the events corresponding to the given event name. You
          can also pass in a dictionary of event names, which makes it
          possible to specify error and end event names. Otherwise, these
          default to `error` and `end`.
        examples:
          code: 'clickStream = events "click", button'
      - title: stream
        description: >-
          Given a stream object, returns a reactor whose products correspond
          to those of the stream. This is useful for treating a stream as a
          reactor.
        examples:
          code: |-
            tokens = fold cat, [], [
              stream fs.createReadStream path
              map (chunk) -> chunk.split /\s+/
            ]

      - title: flow
        description: >-
          Given an producer and a list of functions, composes the functions
          (via [`pipe`](#pipe)) and then invokes the resulting function with
          the producer, returning another producer.
        examples:
          code: |-
            squares = (numbers) ->
              flow [
                numbers
                map (n) -> n * n
              ]

            i = squares [1..5]
            assert (value next i) == 1
            assert (value next i) == 4
            assert (value next i) == 9
            assert (value next i) == 16
            assert (value next i) == 25
            assert isDone i

  - title: Filters
    description: Filters transform producers into other producers.
    content:

    - title: map
      description: >-
        Given a unary function and a producer, returns a new producer whose
        products are obtained by applying the function to the products of
        the original producer.
      examples:
        code: |-
          i = map Math.sqrt, [1,4,9,16,25]
          assert (value next i) == 1
          assert (value next i) == 2
          assert (value next i) == 3
          assert (value next i) == 4
          assert (value next i) == 5
          assert isDone i

    - title: accumulate
      description: >-
        Given a binary function, an initial value, and a producer, returns a
        new producer whose products are obtained by applying the function to
        a running (accumulated) value and the products of the original
        producer.

        This works like [`reduce`](#reduce) except it produces the values
        returned by the reduce function instead of just the final value.
      examples:
        code: |-
          i = accumulate add, 0, [1..5]
          assert (value next i) == 1
          assert (value next i) == 3
          assert (value next i) == 6
          assert (value next i) == 10
          assert (value next i) == 15
          assert isDone i

    - title: select/filter
      description: >-
        Given a function and a producer, return a producer whose products
        are obtained by applying the function to the products of the
        original producer until it finds one for which the function return
        true.
      examples:
        code: |-
          i = select odd, [1..5]
          assert (value next i) == 1
          assert (value next i) == 3
          assert (value next i) == 5
          assert isDone i

    - title: reject
      description: >-
        Given a function and a producer, return a producer whose products
        are obtained by applying the function to the products of the
        original producer until it finds one for which the function return
        false. This is the complement to [`select`](#select).
      examples:
        code: |-
          i = reject odd, [1..5]
          assert (value next i) == 2
          assert (value next i) == 4
          assert isDone i

    - title: project
      description: >-
        Given a property specifier (see [`property`](#property)) and a
        producer, return a producer whose products are obtained by taking
        the given property from the product values of the original producer.
        Equalent to `map (property specifier)`.
      examples:
        code: |-
          i = project ["name", "first"], people
          assert (value next i) == "Jack"
          assert (value next i) == "Jill"

    - title: compact
      description: >-
        Given a producer, returns a producer whose products are the products
        from the original producer with defined values. Equivalent to
        `select isDefined`.
      examples:
        code: |-
          i = compact [1, undefined, 2, undefined, 3]
          assert (value next i) == 1
          assert (value next i) == 2
          assert (value next i) == 3
          assert isDone i

    - title: partition
      description: >-
        Given an integer and a producer, returns a producers whose products
        are arrays of products from the original producer, whose length is
        equal to (or less than, for the last product) the given integer.
      examples:
        code: |-
          i = partition 2, [1..10]
          assert (first value next i) == 1
          assert (first value next i) == 3
          assert (first value next i) == 5
          assert (first value next i) == 7
          assert (first value next i) == 9
          assert isDone i

    - title: take
      description: >-
        Given a function and a producer, return a producer whose products
        are those of the original producer, until the given function returns
        false when applied to the products.
      examples:
        code: |-
          i = take ((n) -> n <= 5), [1..10]
          assert (value next i) == 1
          assert (value next i) == 2
          assert (value next i) == 3
          assert (value next i) == 4
          assert (value next i) == 5
          assert isDone i

    - title: takeN
      description: >-
        Given an integer _n_ and a producer, returns a producer whose
        products are the first _n_ products of the original producer.
      examples:
        code: |-
          i = takeN 5, [1..10]
          assert (value next i) == 1
          assert (value next i) == 2
          assert (value next i) == 3
          assert (value next i) == 4
          assert (value next i) == 5
          assert isDone i

    - title: where
      description: >-
        Given a query _q_ and a producer _p_, equivalent to `select query q,
        p`. See also: [`query`](#query).
      examples:
        code: |-
          i = where length: 3, ["one", "two", "three"]
          assert (value next i) == "one"
          assert (value next i) == "two"
          assert isDone i

    - title: lines
      description: >-
        Given a producer whose products are strings, returns a producer
        whose products are the strings of the original producer, delimited
        by newlines.
      examples:
        description: >-
          Define a functon that computes the average line length of a given
          file.
        code: |-
          averageLineLength = (path) ->
            average [
              stream create fs.createReadStream path
              lines
              project "length"
            ]

    - title: tee
      description: >-
        Given a function and a producer, returns a producer whose products
        are those of the original producers. The given function is also
        applied to the original products. This function is like `map` except
        that it doesn't return the result of applying the function to the
        original product, it just returns the product. This is useful if you
        want to use the product more than once within a flow.
      examples:
        description: >-
          Here's an HTTP server that passes a request context to a handler
          and then logs it in a fashion similar to Express/Connect
          middleware.
        code: |-
          go [
            events "request", server
            map spread (request, response) -> {request, response}
            tee (context) -> handler context
            map spread logger
          ]

    - title: throttle
      description: >-
        Given a integer specifying an interval in milliseconds and reactor,
        returns a reactor whose product are those of the original reactor,
        provided that the interval between any consecutive products is
        greater than the given interval. Products are discarded until the
        interval is reached or exceeded.
      examples:
        description: >-
          Here is a file update watcher that ignores updates that occur
          close together.
        code: |-
          watch = (path, interval=3000) ->
            go [
              events "change", fs.watch path
              throttle interval
            ]

    - title: pump
      description: >-
        Given a stream and a producer, returns a producer whose products are
        the stream after writing the product of the original producer to the
        stream.
      examples:
        description: Here is a simple echo server.
        code: |-
          go [
            events name: "connection", end: "close",
              net.createServer().listen(1337)
            map (s) ->
              go [
                stream s
                pump s
              ]
          ]
    - title: zip
      description: >-
        Given a function and two producers, return a producer whose products
        are obtained by applying the given function to the products of the
        original producer.

  - title: Reducers
    description: >-
      Some functions _reduce_ an iterator into another value. Once a reduce
      function is introduced, the associated iterator functions will run.
    content:
    - title: fold/reduce
      description: >-
        Given a function, an initial value, and a producer, reduce the
        producer to a single value, ex: sum a list of integers.
      examples:
        code: 'assert (reduce add, 0, [1..5]) == 15'
    - title: foldr/reduceRight
      description: >-
        Given an initial value, a function, and a producer, reduce the
        producer to a single value, ex: sum a list of integers, starting
        from the last (or rightmost) value.
      examples:
        code: 'assert (foldr add, "", "panama") == "amanap"'
    - title: collect
      description: 'Given a producer, collect its product values into an array.'
      examples:
        code: |-
          results = collect accumulate add, 0, [1..5]
          assert results[0] == 1
          assert results[0] == 3
          assert results[0] == 6
          assert results[0] == 10
          assert results[0] == 15
          assert results.length == 5
    - title: each
      description: >-
        Given a function _f_ and a producer _p_, equivalent to `start map f,
        p`. Useful for applying a function to a producer without collecting
        the results.
      examples:
        code: 'each ((value) -> console.log value), [1..5]'
    - title: start
      description: >-
        Given a reactor, calls `next` until the reactor is exhausted. (That
        is, it's products' `done` property returns true.) Does not return a
        value.
      examples:
        code: 'start map log, events'
    - title: any
      description: >-
        Given a function and a producer, return true if the given function
        returns true for any product value.
      examples:
        code: 'assert any odd, [1..5]'
    - title: all
      description: >-
        Given a function and a producer, return true if the given function
        returns true for all the product values.
      examples:
        code: 'assert all ((n) -> n <= 5), [1..5]'
    - title: assoc
      description: >-
        Given an producer whose products are associative pairs, return an
        object whose keys are the first element of the pair and whose values
        are the second element of the pair.
      examples:
        code: >-
          person = assoc [["name", "Long John Silver"], ["occupation"],
          "Pirate"]]

          assert person.name == "Long John Silver" &&
            person.occupation == "Pirate"
    - title: flatten
      description: >-
        Given a producer whose product values may themselves be producers,
        return an array whose elements are the products of a depth-first
        traversal of the resulting producer tree.
      examples:
        code: |-
          values = (flatten [1, [2, 3], 4, [5, [6, 7]]])
          assert values[0] == 1
          assert values[0] == 2
          assert values[0] == 3
          assert values[0] == 4
          assert values[0] == 5
          assert values[0] == 6
          assert values[0] == 7
          assert (length values) == 7
    - title: sum
      description: >-
        Given a producer _p_ whose products are numbers, return their sum.
        Equivalent to `fold add, 0`.
      examples:
        code: 'assert (sum [1..5]) == 15'
    - title: average
      description: >-
        Given a producer _p_ whose products are numbers, return their
        average.
      examples:
        code: 'assert (average [1..5]) == 3'
    - title: join
      description: >-
        Given a producer whose products are strings, concatenate the
        strings. Unlike `Array::join`, this function does not delimit the
        strings. See also: `delimit`.

        This is here instead of in [String Functions](./string.litcoffee) to
        avoid forward declaring `fold`.
      examples:
        code: assert (join w "one two three") == "onetwothree"
    - title: delimit
      description: >-
        Given a delimiter and a producer whose products are strings,
        concatenate the strings using the delimiter.

        Like `join`, except that it each string is separated with the
        delimiter. Similar to `Array::join`, except there's no default
        delimiter and the function is curried. Calling `delimit ' '` is the
        same as calling `Array::join` with no delimiter argument.
      examples:
        code: 'assert (delimit ", ", w "one two three") == "one, two, three"'

- title: Helpers
  module: fairmont-helpers
  description: >-
    Helper functions for working with JavaScript's built-in types,
    including Arrays, Objects, Promises, and the prototype chain,
    in a functional style.

  content:
  - title: Array Helpers
    description: ''
    content:

    - title: push
      description: >-
        Attach one or more elements to the right side of the given array.
        `push` takes a target array and N elements to attach.  `push`
        directly affects the target array as a side effect, while also
        returning the augmented array.

        Note that pushing an array onto an array results in a nested array.
        For ***joining*** arrays, you may use `cat` or CoffeeScript's splat
        operator.
      examples:
        code: >-
          # Directly affects "fruits" without storing return value.

          fruits = ["apple", "blueberry"]

          push fruits, "strawberry"

          assert.deepEqual fruits, ["apple", "blueberry", "strawberry"]


          citrus = ["lemon", "lime"]

          push fruits, citrus

          assert.deepEqual fruits, ["apple", "blueberry", "strawberry",
          ["lemon", "lime"]]


          # push accepts more than one element.

          fruits = ["apple", "blueberry"]

          push fruits, "strawberry", citrus

          assert.deepEqual fruits, ["apple", "blueberry", "strawberry",
          ["lemon", "lime"]]


          # With CoffeeScript's splat operator, we may achieve array
          concatenation.

          fruits = ["apple", "blueberry"]

          push fruits, "strawberry", citrus...

          assert.deepEqual fruits, ["apple", "blueberry", "strawberry",
          "lemon", "lime"]

    - title: cat
      description: >-
        Takes two arrays and concatenates (joins) them.  Returns the new,
        single array.  The input arrays remain unchanged.
      examples:
        code: |-
          fruits = ["apple", "blueberry"]
          citrus = ["lemon", "lime"]
          fruits = cat fruits, citrus
          assert.deepEqual fruits, ["apple", "blueberry", "lemon", "lime"]

    - title: slice
      description: >-
        Extract a subset of an array.  `slice` takes two numbers and an
        array.  The two numbers specify a start and end index for the
        desired sub-array within the input array.  Both indices are
        zero-based, inclusive on the start index, and exclusive on the end
        index.  `slice` returns a sub-array, as specified, while leaving the
        original array unchanged.

        `slice` may also be used with strings where it treats characters
        like members of an array.  `slice` returns a sub-string when working
        with strings.

        When specifying an end index in excess of the array's length, the
        sub-array will only extend to the end of the original array.  The
        end index is allowed to be negative, where it counts to the left
        from the end of the target array.  The start index must be smaller
        than the end index, except when the end index is negative.  Invalid
        indices cause `slice` to return an empty array.

        `slice` is curried, meaning that it returns a function when given an
        insufficient number of arguments.  This new function accepts the
        remaining arguments, see the "snip" example below.
      examples:
        code: >-
          fruits = ["apple", "blueberry", "lemon", "lime", "orange",
          "strawberry", "cherry"]

          citrus = slice 2, 5, fruits

          assert.deepEqual citrus, ["lemon", "lime", "orange"]


          # Works on strings too.

          string = "supercalifragilisticexpialidocious"

          sub_string = slice 9, 20, string

          assert.deepEqual sub_string, "fragilistic"


          # Even if the end index is large, slice can only go as far the
          original array.

          long = slice 2, 10, fruits

          assert.deepEqual long, ["lemon", "lime", "orange", "strawberry",
          "cherry"]


          # The end index may be negative, counting from the right side of
          the original array.

          negative = slice 1, -2, fruits

          assert.deepEqual negative, ["blueberry", "lemon", "lime",
          "orange"]




          # Slice is curried, so it returns a function when you don't pass
          all three arguments.

          snip = slice 2, 5


          # And the new function takes only the remaining argument (or
          arguments).

          f = snip fruits

          assert.deepEqual f, ['lemon', 'lime', 'orange']


          # Just to be clear, snip is reusable as a function.

          ax = [1..10]

          bx = [11..20]


          a = snip ax

          b = snip bx

          assert.deepEqual a, [ 3, 4, 5 ]

          assert.deepEqual b, [13, 14, 15]
    - title: 'first, second, third, fourth, fifth'
      description: >-
        Takes an array or string.  For arrays, returns the first, second,
        third, fourth, and fifth element, respectively.  For strings,
        returns the first, second, third, fourth, and fifth character,
        respectively.  Returns `undefined` for objects and numbers.
      examples:
        code: >-
          fruits = ["apple", "blueberry", "lemon", "lime", "orange",
          "strawberry", "cherry"]

          string = "supercalifragilisticexpialidocious"


          fruit = first fruits

          assert.deepEqual fruit, "apple"


          char = second string

          assert.deepEqual char, "u"


          fruit = third fruits

          assert.deepEqual fruit, "lemon"


          char = fourth string

          assert.deepEqual char, "e"


          fruit = fifth fruits

          assert.deepEqual fruit, "orange"
    - title: nth
      description: >-
        A generalization of `first`, `second`, etc, from above.  `nth` takes
        an index and either an array or string.    Returns the element (or
        character) at the specified index, however the index is one-based.
        This stands in contrast to the usual, zero-based index in
        JavaScript.  `nth` returns `undefined` for objects and numbers.
      examples:
        code: >-
          fruits = ["apple", "blueberry", "lemon", "lime", "orange",
          "strawberry", "cherry"]

          string = "supercalifragilisticexpialidocious"


          fruit = nth 3, fruits

          assert.deepEqual fruit, "lemon"


          char = nth 22, string

          assert.deepEqual char, "x"
    - title: last
      description: >-
        Takes an array or string.  For arrays, `last` returns the last
        element.  For strings, `last` returns the last character.  `last`
        returns `undefined` for objects and numbers.
      examples:
        code: >-
          fruits = ["apple", "blueberry", "lemon", "lime", "orange",
          "strawberry", "cherry"]

          string = "supercalifragilisticexpialidocious"


          fruit = last fruits

          assert.deepEqual fruit, "cherry"


          char = last string

          assert.deepEqual char, "s"
    - title: rest
      description: >-
        Takes an array or string.  For arrays, `rest` returns a sub-array
        containing all elements *except* the first.  For strings, `rest`
        returns a sub-string containing all characters *except* the first.
        `rest` returns `undefined` for objects and numbers.
      examples:
        code: >-
          fruits = ["apple", "blueberry", "lemon", "lime", "orange",
          "strawberry", "cherry"]

          string = "supercalifragilisticexpialidocious"


          bunch = rest fruits

          assert.deepEqual bunch, ["blueberry", "lemon", "lime", "orange",
          "strawberry", "cherry"]


          char = rest string

          assert.deepEqual char, "upercalifragilisticexpialidocious"
    - title: includes
      description: >-
        Check if an element is a member of an array.  Takes a candidate
        element and the array to test.  Returns `true` or `false`.
      examples:
        code: >-
          fruits = ["apple", "blueberry", "lemon", "lime", "orange",
          "strawberry", "cherry"]


          is_present = includes "lemon", fruits

          assert.deepEqual fruit, true


          is_present = includes "pear", fruits

          assert.deepEqual fruit, false
    - title: unique
      description: >-
        Strip repeated elements out of an input.  Takes a single array or
        string as input.  For arrays, `unique` returns a new array
        containing only the unique members of the original.  For strings,
        `unique` returns a new array containing unique *characters* from the
        original string.  For inputs that are a JavaScript object or number,
        `unique` returns an empty array.  In all cases, the original input
        remains unchanged.
      examples:
        code: >-
          fruits = ["apple", "lemon", "apple", "lime", "apple", "orange",
          "apple", "cherry"]

          string = "supercalifragilisticexpialidocious"


          fruit = unique fruits

          assert.deepEqual fruit, ["apple", "lemon", "lime", "orange",
          "cherry"]


          letters = unique string

          assert.deepEqual letters, ['s', 'u', 'p', 'e', 'r', 'c', 'a', 'l',
          'i', 'f', 'g', 't', 'x', 'd', 'o']
    - title: uniqueBy
      description: >-
        A generalized version of [`unique`](#unique).  `uniqueBy` takes an
        input function, `f()`, and an array, `a`.  `f()` is mapped on the
        members of `a`, transforming them, ie `f()` should be designed to
        act upon one element at a time.   `uniqueBy` returns a new array
        containing only the unique members ***after*** being transfomred by
        `f()`.
      examples:
        code: >-
          numbers = [2, 3, 6, 9, 10, 14, 15, 18, 21, 22, 26, 27, 30, 33, 34,
          39, 45, 51]

          f = (x) -> if x % 2 == 0 then x * 3 else x * 2


          output = uniqueBy f, numbers

          assert.deepEqual output, [6, 18, 30, 42, 54, 66, 78, 90, 102]
    - title: dupes
      description: >-
        Locate duplicated, or repeated, elements in an array.  Takes a
        single array or string as input.  For arrays, `dupes` returns a new
        array containing only the members of the original that appear more
        than once.  For strings, `dupes` returns a new array containing
        ***characters*** from the original string that appear more than
        once.  For inputs that are a JavaScript object or number, `dupes`
        returns an empty array.  In all cases, the original input remains
        unchanged.
      examples:
        code: >-
          fruits = ["apple", "lemon", "apple", "lime", "apple", "orange",
          "apple", "cherry"]

          string = "supercalifragilisticexpialidocious"


          fruit = dupes fruits

          assert.deepEqual fruit, ["apple"]


          letters = dupes string

          assert.deepEqual letters, ['u', 'p', 'e', 'r', 'a', 'l', 's', 'c',
          'i', 'o']
    - title: union
      description: >-
        Generate the [set union][set-union] of two arrays.  `union` takes
        two arrays and returns a new, concatenated array with any duplicate
        elements removed.  The original arrays remain unchanged.
      examples:
        code: >-
          fruits1 = ["apple", "lemon", "apple", "lime", "apple", "orange",
          "apple", "cherry"]

          fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
          "apple", "cherry"]


          output = union fruits1, fruits2

          assert.deepEqual output, ['apple', 'lemon', 'lime', 'orange',
          'cherry', 'pear', 'mango', 'kiwi']


          letters = dupes string

          assert.deepEqual letters, ['u', 'p', 'e', 'r', 'a', 'l', 's', 'c',
          'i', 'o']
    - title: intersection
      description: >-
        Generate the [set intersection][set-intersection] of two arrays.
        `intersection` takes two arrays and returns a new, single array of
        elements present in both arrays.  This includes repeated elements if
        and only if they are repeated in both inputs.  The original arrays
        remain unchanged.
      examples:
        code: >-
          fruits1 = ["apple", "lemon", "apple", "lime", "apple", "orange",
          "apple", "cherry"]

          fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
          "apple", "cherry"]


          output = intersection fruits1, fruits2

          assert.deepEqual output, ["apple", "lemon", "lime", "apple",
          "cherry"]
    - title: difference
      description: >-
        Generate the [symmetric difference][symmetric-difference] of two
        arrays.  `difference` takes two arrays and returns a new, single
        array of elements that are not shared between the inputs.
        Additionally, the output array presents only ***unique*** elements,
        removing duplicates.  The original arrays remain unchanged.
      examples:
        code: >-
          fruits1 = ["apple", "orange", "lemon", "apple", "lime", "apple",
          "orange", "apple", "cherry"]

          fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
          "apple", "cherry", "mango"]


          output = difference fruits1, fruits2

          assert.deepEqual output, ["orange", "pear", "mango", "kiwi"]
    - title: complement
      description: >-
        Generate the [relative complement][relative-complement] of an array
        with respect to another.  `complement` takes two arrays, `a` and
        `b`, and returns a new array of elements that are present in `a` but
        not `b`.  This includes repeated elements if `a` has duplicates.
        The original arrays remain unchanged.
      examples:
        code: >-
          fruits1 = ["apple", "orange", "lemon", "apple", "lime", "apple",
          "orange", "apple", "cherry"]

          fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
          "apple", "cherry", "mango"]


          # Note that order matters.  Relative complement is not
          associative.

          output = complement fruits1, fruits2

          assert.deepEqual output, ["orange", "orange"]


          output = complement fruits2, fruits1

          assert.deepEqual output, ["pear", "mango", "kiwi", "mango"]
    - title: remove
      description: >-
        Destructively remove an element from an array. `remove` takes a
        candidate element and array.  `remove` returns the element if it is
        present in the array.  If it is not present, `remove` returns
        `null`.

        The input array is altered by `remove` if the element is present.
        If there is more than one instance of the element within the array,
        only the first instance is removed.
      examples:
        code: >-
          fruits = ["apple", "orange", "lemon", "apple", "lime", "apple"]


          output = remove "orange", fruits

          assert.deepEqual output, "orange"

          assert.deepEqual fruits, ["apple", "lemon", "apple", "lime",
          "apple"]


          output = remove "apple", fruits

          assert.deepEqual output, "apple"

          assert.deepEqual fruits, ["lemon", "apple", "lime", "apple"]


          output = remove "orange", fruits

          assert.deepEqual output, null

          assert.deepEqual fruits, ["lemon", "apple", "lime", "apple"]
    - title: shuffle
      description: >-
        Randomize the order of elements within an array.  `shuffle` takes an
        array and returns a new array where all values have been ordered
        pseudorandomly.  Please note that `shuffle` is ***guaranteed*** to
        produce a different ordering (which is a non-random behavoir).
        Specifically, `shuffle` uses the [Fisher-Yates algorithm][shuffle-1]
        as adapted from [this CoffeeScript Cookbook recipe][shuffle-2].
      examples:
        code: |-
          numbers = [1..10]

          scrambled = shuffle numbers
          assert.notDeepEqual numbers, scrambled
          # Example result, [ 5, 2, 4, 9, 8, 10, 1, 7, 3, 6 ]
    - title: range
      description: >-
        Generate an array of ordered integers.  `range` takes two numbers
        specifying the start and end of the titular range.  `range` returns
        a new array containing an ordered list, either ascending or
        descending, of all integers from the start value to end value,
        inclusive.  When the start and end values are identical, an array
        with one element is returned.  Invalid input causes `range` to
        return an empty array.
      examples:
        code: |-
          output = range 1, 5
          assert.deepEqual output, [1, 2, 3, 4, 5]

          output = range 5, 1
          assert.deepEqual output, [5, 4, 3, 2, 1]

          output = range 5, 5
          assert.deepEqual output, [ 5 ]

          output = range 1, "foobar"
          assert.deepEqual output, []

  - title: Hashing/Encoding Functions
    description: ''
    content:

    - title: md5
      description: |
        Generate the [MD5 hash][md5-1] of a string.  `md5` takes a UTF-8
        encoded string.  Returns a the hash result of the MD5 message digest
        algorithm.  The hash is 128-bit value, represented as a stringified
        32 digit hexidecimal number.

        [md5-1]:https://en.wikipedia.org/wiki/MD5

      examples:
        code: >-
          output = md5 "panda"

          assert output == "ce61649168c4550c2f7acab92354dc6e"


          # Putting in the same string will yield the same output.

          output = md5 "panda"

          assert output == "ce61649168c4550c2f7acab92354dc6e"


          # The output of md5 is always the same length.

          output = md5 "Regardless of the length of the input string, this
          MD5 function always returns a 32 digit hexidecimal number."

          assert output == "682f5e81981d68d2b196137042d17c79"

    - title: base64
      description: >-
        Convert a string to Base64 encoding.  `base64` takes an UTF-8
        encoded string.  Returns a string of the same content, but encoded
        in Base64.  Please note that this function ***does not*** produce a
        URL-safe string.  Please use `base64url` for that case.
      examples:
        code: |-
          output = base64 "abc123!?$*&()'-=@~~"
          assert output == "YWJjMTIzIT8kKiYoKSctPUB+fg"

    - title: base64url
      description: >-
        Convert a string to a URL-safe variant of Base64 encoding.
        `base64url` takes an UTF-8 encoded string.  Returns a string of the
        same content, but encoded in a URL-safe variant of Base64, based on
        [RFC 4648's][base64url-1] "base64url" mapping.  The URL-safe variant
        avoids outputting `+`, `/`, or `=`, but is otherwise very similar to
        `base64`.
      examples:
        code: |-
          output = base64url "abc123!?$*&()'-=@~~"
          assert output == "YWJjMTIzIT8kKiYoKSctPUB-fg"

  - title: Generators
    description: ''
    content:
    - title: call
      description: |
        Execute a generator containing asynchronous instructions.  Takes a
        generator and is a pass-through for its return.

        ES6's introduction of generators offers a wonderful way to handle
        asynchronous methods.  A generator is any function with one or more
        `yield` operators, which is where the execution enters a
        non-blocking wait for the result.  However, we cannot use `yield`
        without a containing generator.  `call` is a convenience function
        that lets you to wrap your async code with a generator that
        immediately begins executing.
      examples:
        code: >-
          # Putting in the asynchronous sleep is contrived, but it keeps
          this simple.

          call ->
            string = "panda"
            yield sleep 100
            assert string == "panda"

    - title: async
      description: |
        Establish a reusable generator function by wrapping it in a
        promise.  Takes a generator and returns a promise that either
        ***resolves*** the return value or ***rejects*** with an error.

        ES6's introduction of generators offers a wonderful way to handle
        asynchronous methods.  A generator is any function with one or more
        `yield` operators, which is where the execution enters a
        non-blocking wait for the result.  The trick to writing asynchronous
        code that follows a synchronous pattern is to always pair the
        `yield` operator with a promise.

        That means when we write a generator that we'd like to reuse, we
        need to wrap it in a promise.  But it can be a burden to make your
        code promise aware.  Which is why Fairmont includes `async` as
        convenience function to handle all that for you.  As long as you
        include `yield`, you are free to write in a synchronous pattern.
        `async` will promisify your generator and allow you to continue the
        `yield` pattern throughout your callstack.
      examples:
        code: >-
          # Putting in the asynchronous sleep is contrived, but it keeps
          this simple.

          square = async (x) ->
            yield sleep 100
            x**2

          call ->
            a = 2
            a = yield square a
            a = yield square a
            a = yield square a
            assert a == 256

  - title: Numeric Functions
    description: ''
    content:

    - title: 'gt, lt, gte, lte'
      description: Curries a value to allow future evaluation of relative value.
      examples:
        code: |-
          recruits = add 5
          assert recruits 1 == 6

    - title: 'odd, even'
      description: Evaluates whether a value is odd or even.
      examples:
        code: assert odd 5

    - title: Functions exported from Math
      description: |-
        #####min, max
        Gives the lowest or highest value in a set of numbers.
      examples:
        code: 'assert pow(3, 3) == 27'

  - title: Object Functions
    description: ''
    content:

    - title: 'include, extend'
      description: >-
        Add the properties of one or more objects to another. Aliased as
        `extend`.  Takes a base object and N additional objects. `include`
        directly affects the base object as a side effect, while also
        returning the augmented object.  The additional objects (not the
        base object) remain unchanged.

        All properties that exist among the input objects will exist in the
        resultant object.  If a object property already exists, the last
        value entered will overwrite the previous.
      examples:
        code: >-
          stats = {hp: 50, mp: 100}


          include stats, {stamina: 10, strength: 10}, {intelligence: 50,
          agility: 20}

          assert.deepEqual Object.keys(stats), ["hp", "mp", "stamina",
          "strength", "intelligence", "agility"]


          include stats, {stamina: 50}

          assert stats.stamina == 50

    - title: merge
      description: >-
        Create a new object by merging the properties of one or more objects
        together.  Takes N objects. Returns a new object containing the
        properties of all input objects.

        `merge` is a more generalized accumulation function that always
        returns a new object.  If a object property already exists in
        another object, the last value entered will overwrite the previous.
      examples:
        code: >-
          stats = {hp: 50, mp: 100}


          stats = merge {hp: 50, mp: 100}, {stamina: 10, strength: 10},
          {intelligence: 50, agility: 20}

          assert.deepEqual Object.keys(stats), ["hp", "mp", "stamina",
          "strength", "intelligence", "agility"]
    - title: clone
      description: >-
        Perform a deep clone on an object. Takes an object and returns a new
        object copy.

        The algorithm for copying the object is taken from [The CoffeeScript
        Cookboox][clone-1].  `clone` uses a recursive process to copy nested
        properties, providing a *deep* clone.  When passed a non-object,
        `clone` will still return a copy of what it is passed.
      examples:
        code: >-
          person =
            name: "Steve Jobs"
            address:
              street: "1 Infinite Loop"
              city: "Cupertino, CA"
              zip: 95014
            birthdate: new Date 'Feb 24, 1955'
            regex: /foo.*/igm


          assert.notEqual  (clone person), person  # Because birthdate ==
          Date.getTime()

          assert.deepEqual (clone person), person


          assert (clone 1) == 1
    - title: property
      description: >-
        Extract a property from an object.  Takes a property name and a
        target object.  `property` returns the value of property on the
        target object.

        `property` is curried, meaning that it returns a function if you
        pass in only one of its two arguments.  This function will extract
        the set property from any target object.  These curried `property`
        invocations allow you to extract nested properties.
      examples:
        code: |-
          a =
            foo: 1
            bar: 2
            baz:
              foo: 2

          assert (property "foo", a) == 1

          # Curried invocations allow you to extract nested properties.
          bazFoo = (compose (property "foo"), (property "baz"))
          assert (bazFoo a) == 2
    - title: delegate
      description: >-
        Delegate from one object to another.  Takes two objects, the
        delegator and the delegatee.  `delegate` directly modifies the
        delegator's properties to reference the delegatee.

        Delegation is form of property inheritance separate from
        JavaScript's native prototype inheritance.  `delegate` allows any
        calls to the delegator's functions to reference their counterparts
        in the delgatee, if present.  Additionally, the delegator's context
        is shifted to the delgatee.

        The context shift is presented in the example below.  The second
        time we call `a.foo()` and access `this`, we are accessing the
        context of `b`, so `a.foo() == this.bar() == b.bar()`.
      examples:
        code: |-
          a =
            foo: -> this.bar()
            bar: -> "This is a"

          b =
            bar: -> "This is b"

          assert a.foo() == "This is a"
          assert a.bar() == "This is a"

          delegate a, b
          assert a.foo() == "This is b"
          assert a.bar() == "This is b"
    - title: bind
      description: >-
        Define a new function based on a prototype function while keeping
        the instance's context.  Takes a function and a object instance.
        Returns a new function that shares its context with the original
        instance.

        By default, functions copied from prototype functions are bound to
        the outer, calling function's context.  `bind` overrides that
        behavior.  The new function's context will track the original
        instance's state.

        **Important** In the past, this did not always work for some
        natively implemented functions. That is hopefully no longer the
        case.
      examples:
        code: >-
          this.x = 9

          foo =
            x: 81
            getX: -> this.x

          assert foo.getX() == 81     # accesses foo's internal context


          getX = foo.getX

          assert getX() == 9          # "this" refers to the outer or global
          context, not foo's


          boundGetX = bind getX, foo

          assert boundGetX() == 81    # Now, boundGetX's "this" is bound to
          foo's context


          foo.x = 11

          assert boundGetX() == 11    # Note that the context is *shared*,
          not copied.
    - title: detach
      description: >-
        Define a new function based on a prototype function, without taking
        any context.  Takes a function.  Returns a function that accepts a
        context followed by any arguments.

        By default, functions copied from prototype functions are bound to
        the outer, calling function's context.  `detach` overrides that
        behavior.  The new function is untethered from any context.  That
        gives you the control to pick what context should be applied with
        executing.

        **Important** In the past, this did not always work for some
        natively implemented functions. That is hopefully no longer the
        case.
      examples:
        code: >-
          # Establishing an instance of prototype.

          foo = ->

          foo::x = 81

          foo::f = (y) -> this.x / y


          # Establishing secondary contexts.

          this.x = 9

          bar = x: 36


          # Once detached, we may apply the other contexts to "f".

          g = detach foo::f

          assert (g this, 3) == 3

          assert (g bar, 3) == 12



          # Detaching reflective functions creates a function that only
          needs one argument (a context).

          trim = detach String::trim

          assert (trim "  panda    ") == "panda"
    - title: properties
      description: >-
        Attach properties to a prototype.  Takes a target prototype and an
        object filled with the properties you wish to add.  `properties`
        directly adds the object to the target prototype.  Also, returns an
        array of statements associating the properties with the target
        prototype.

        Properties defined using `properties` are enumerable and
        configurable.
      examples:
        code: >-
          # Define a prototype with a property that uses JavaScript's native
          getter and setter.

          class A
            properties @::,
              foo:
                get: -> @_foo
                set: (v) -> @_foo = v

          # Test with an instance of "A".

          a = new A

          a.foo = "bar"

          assert a._foo == "bar"  # Proves the setter was used to create and
          set "_foo".
    - title: has
      description: >-
        Check if an object has a property.  Takes a property name and a
        target object.  Returns `true` if the property is present or `false`
        if it is not.  `has` is curried, meaning that if you pass it only a
        property, `has` return a function that takes only an object and
        checks for that property.
      examples:
        code: >-
          panda =
            color: "black and white"
            limbs: 4

          fish =
            color: "silver"
            limbs: 0

          car =
            color: "red"
            wheels: 4

          assert (has "limbs", panda) == true

          assert (has "limbs", fish) == true

          assert (has "limbs", car) == false


          # has is curried, so we can create a function that always checks
          for the same property.

          wheelCheck = has "wheels"

          assert (wheelCheck panda) == false

          assert (wheelCheck fish) == false

          assert (wheelCheck car) == true
    - title: keys
      description: >-
        Get the keys for an object.  Takes an object.  Returns an array of
        the key names.
      examples:
        code: |-
          panda =
            c: 3
            v: 1
            q: 12
            t: 10

          assert.deepEqual (keys panda), ["c", "v", "q", "t"]
    - title: values
      description: >-
        Get the values for an object.  Takes an object.  Returns an array of
        values for each key.
      examples:
        code: |-
          panda =
            c: 3
            v: 1
            q: 12
            t: 10

          assert.deepEqual (values panda), [3, 1, 12, 10]
    - title: pairs
      description: >-
        Convert an object into association array.  Takes an object.  Returns
        a nested array that pairs the object's keys with its values.
      examples:
        code: >-
          obj =
            a: 1
            b: 2
            c: 3

          output = pairs obj

          assert.deepEqual output, [["a", 1], ["b", 2], ["c", 3]]


          # pairs only works on the top level.  Nested structures will just
          end up in the association array.

          obj =
            a:
              foo: 100
              bar: 200
            b: 2
            c: 3

          output = pairs obj

          assert.deepEqual output, [ [ 'a', { foo: 100, bar: 200 } ], [ 'b',
          2 ], [ 'c', 3 ] ]
    - title: pick
      description: >-
        Filter the properties of an object on the result returned by a
        filter function.  Takes a function and a target object.  Returns a
        new object with only the filtered properties.  The original input
        object remains unchanged.

        The filter function processes the object's properties individually,
        accepting a given key and its value.  If the filter's return value
        is *truthy*, the property is added to the ***new*** object.  If the
        filter's return function is *falsey*, the property is omitted.  In
        this way, the new object is built up with only the desired
        properties.

        `pick` is curried.
      examples:
        code: >-
          fruits =
            apples: 3
            oranges: null
            mangos: 12

          f = (key, value) -> value?            # Only if the value is
          truthy

          g = (key, value) -> value % 2 == 1    # Only if there is an odd
          number

          h = (key, value) -> key == "mangos"   # Really likes mangos?


          assert.deepEqual (pick f, fruits), {apples: 3, mangos: 12}

          assert.deepEqual (pick g, fruits), {apples: 3}

          assert.deepEqual (pick h, fruits), {mangos: 12}
    - title: omit
      description: >-
        The inverse of `pick`.  Filter the properties of an object on the
        result returned by a filter function.  Takes a function and a target
        object.  Returns a new object with only the filtered properties.
        The original input object remains unchanged.

        The filter function processes the object's properties individually,
        accepting a given key and its value.  If the filter's return value
        is *falsey*, the property is added to the ***new*** object.  If the
        filter's return function is *truthy*, the property is omitted.  In
        this way, the new object is built up with only the desired
        properties.

        `omit` is curried.
      examples:
        code: >-
          fruits =
            apples: 3
            oranges: null
            mangos: 12

          f = (key, value) -> value?            # Only if the value is
          falsey

          g = (key, value) -> value % 2 == 0    # Only if there is an even
          number

          h = (key, value) -> key == "mangos"   # Really hates mangos?


          assert.deepEqual (omit f, fruits), {oranges: null}

          assert.deepEqual (omit g, fruits), {apples: 3}

          assert.deepEqual (omit h, fruits), {apples: 3, oranges: null}
    - title: query
      description: >-
        Check if an object has a given sub-object.  Takes a sub-object and a
        target object.  Returns `true` if the sub-object is found within the
        target or `false` if it is not.  `query` does not recurse beyond the
        first level of a nested target structure.  However, `query` can
        match on sub-objects with multiple members, including when the
        sub-object's shape is incongruent to the one within the target
        object.

        `query` may also be used with non-objects, however it only returns
        `true` on a `deepEqual` match, rather than checking for
        substructures within the target.

        `query` is curried.
      examples:
        code: >-
          princess =
            name: "Aurora"
            alias:
              name: "Sleeping Beauty"
            dwarves: 7
            enemy: "Maleficent"

          # Query will find an object within a larger object.

          assert query({name: "Aurora"}, princess) == true

          assert query({name: "Belle"}, princess) == false


          # But query cannot find the sub-object within a nested structure.

          findBeauty = query {name: "Sleeping Beauty"}

          assert findBeauty(princess) == false

          assert findBeauty(princess.alias) == true


          # If query is passed non-objects, it simply performs a deepEqual
          comparison.

          princesses = [
            "Ariel", "Aurora", "Belle", "Cinderella",
            "Jasmine", "Merida", "Mulan", "Pocahontas",
            "Rapunzel", "Snow White", "Tiana"
          ]


          assert query({name: "Aurora"}, princesses) == false

          assert query("Aurora", princesses) == false

          assert query(11, princesses.length) == true
    - title: 'toJSON, fromJSON'
      description: >-
        Stringify a JSON object and vice-versa.

        `toJSON` accepts a JavaScript data structure and an optional
        "pretty-print" boolean.  Returns a new string containing the data
        structure in JSON.  If the "pretty-print" value is set to `true`,
        the result will feature newline characters and 2-space indentation.
        If `false`, the result will feature no extra spaces or newlines. The
        "pretty-print" value defaults to false.
      examples:
        code: >-
          mage = fromJSON
          '{"vitals":{"hp":50,"mp":100},"attributes":{"stamina":10,"strength":10,"intelligence":50,"agility":20}}'


          assert mage,
            vitals:
              hp: 50
              mp: 100
            attributes:
              stamina: 10
              strength: 10
              intelligence: 50
              agility: 20

  - title: String Functions
    description: ''
    content:
    - title: toString
      description: Converts a value to a string format.
      examples:
        code: assert toString 12345 == "12345"
    - title: toUpper
      description: Makes all characters in a string upper-case.
      examples:
        code: assert toUpper("allcaps") == "ALLCAPS"
    - title: toLower
      description: Makes all characters in a string lower-case.
      examples:
        code: assert toLower ("LOWERCASE") == "lowercase"
    - title: plainText
      description: |-
        Convert an camel-case or underscore- or dash-separated string into a
        whitespace separated string.
      examples:
        code: assert plainText ("Camel_under-dash") == "camel under dash"
    - title: capitalize
      description: Capitalize the first letter of a string.
      examples:
        code: assert capitalize ("america") == "America"
    - title: titleCase
      description: Capitalize the first letter of each word in a string.
      examples:
        code: assert capitalize ("los angeles") == "Los Angeles"
    - title: camelCase
      description: Convert a sequence of words into a camel-cased string.
      examples:
        code: assert camelCase ("tostring") == "toString"
    - title: underscored
      description: Convert a sequence of words into an underscore-separated string.
      examples:
        code: assert underscored ("one two three") == "one_two_three"
    - title: dashed
      description: Convert a sequence of words into a dash-separated string.
      examples:
        code: assert dashed ("one two three") == "one-two-three"
    - title: htmlEscape
      description: >-
        Escape a string so that it can be embedded into HTML. Adapted from
        Mustache.js.
      examples:
        code: >-
          assert htmlEscape ("<a href="www.msnbc.com">News Site</a>") ==
          "&lt;a href=&quot;www.msnbc.com&quot;&gt;News Site&lt;/a&gt;"
    - title: w
      description: >-
        Split a string on whitespace. Useful for concisely creating arrays
        of strings.
      examples:
        code: |-
          tres = w ("1 2 3")
          console.log(tres)
          # Will print ['1', '2', '3']
          assert tres.length == 3
    - title: blank
      description: Check to see if a string has zero length.
      examples:
        code: assert blank ("")
  - title: Type Functions
    description: ''
    content:
    - title: prototype
      description: >-
        Returns the prototype of the given value using
        `Object.getPrototypeOf`.
    - title: isPrototype
      description: >-
        Binary predicate for determining whether the given prototype is the
        prototype for the given value.
      examples:
        code: 'assert isPrototype Number.prototype, 7'
    - title: isType
      description: Verifies whether a variable is a specified type.
      content:
        - title: 'examples:'
          description: ''
    - title: isTransitivePrototype
      description: >-
        Binary predicate for determining whether the given prototype is in
        the prototype chain for the given value.
      examples:
        code: 'assert isTransitivePrototype Error.prototype, (new TypeError)'
    - title: isKind
      description: >-
        Binary predicate for determining whether the given type's
        `prototype` property is in the prototype chain for the given value.
      examples:
        code: 'assert isKind Error, (new TypeError)'
    - title: instanceOf
      description: Wrapper around `instanceof` operator.
    - title: isNumber
      description: Verifies that an input has a numeric value.
      examples:
        code: assert isNumber 7
    - title: isNaN
      description: Verifies whether a given value is `NaN`.
      examples:
        code: assert !isNaN 7
    - title: isFinite
      description: ''
    - title: isInteger
      description: ''
    - title: isFloat
      description: |-
        Verifies that is an argument is a number of a specific type.
        Adapted from [StackOverflow][isFloat].
      examples:
        code: assert isFloat 3.5
    - title: isBoolean
      description: Verifies that an argument is Boolean.
      examples:
        code: assert isBoolean true
    - title: isDate
      description: Verifies that a variable contains a date.
      examples:
        code: assert isDate (new Date)
    - title: isRegExp
      description: >-
        Verifies that an input is a regular expression. Regular expressions
        are used as a basis for string searches.
      examples:
        code: assert isRegExp /\s/
    - title: isString
      description: Verifies that a variable contains a string of characters.
      examples:
        code: assert isString "Hello"
    - title: isFunction
      description: >-
        Verifies that a variable is a function. A function takes one or more
        arguments as input and returns a value.
      examples:
        code: |-
          func = (a) -> a*a
          assert isFunction func
    - title: isObject
      description: Verifies that a variable is an object.
      examples:
        code: |-
          thing = {one: 1, two: 2}
          assert isObject thing
    - title: isArray
      description: Verifies that a value is an array.
      examples:
        code: 'assert isArray [1, 2, 3, 4, 5]'
    - title: isDefined
      description: Verifies that a value exists.
      examples:
        code: assert isDefined String
    - title: isGenerator
      description: >-
        Verifies that a variable is a generator. A generator can be used to
        systematically create iterators, with the subsequent steps built in
        ahead of time.

        Generators facilitate automation and simplify the task of creating
        iterators.
      examples:
        code: |-
          count = () ->
            yield 1
            yield 2
            yield 3
          assert isGenerator count
    - title: isPromise
      description: >-
        Verifies that a variable is a promise. A promise is essentially a
        link in a chain of operations, that checks to see whether a given
        condition has been met. If the condition is fulfilled, it moves on
        to another designated process (generally another promise). If an
        unexpected result occurs, the promise is rejected and it moves on to
        a different designated outcome. Otherwise, a promise is in its
        pending state. In other words, promises have "then" functionality
        built in.

        Among other things, promises allow easier step by step error
        checking and an ordered series of events in asynchronous
        programming.
      examples:
        code: |-
          promise () ->

          assert isPromise promise
  - title: Utility Functions
    description: >-
      "Utility" is a euphemism for this collection of functions that are very
      useful, but hard to categorize.  For the moment, this is a holding pen
      of sorts for functions that we're not sure what to do with.  As Fairmont
      grows and matures, these functions may be placed into another
      collection.
    content:
      - title: memoize
        description: >-
          Cache the results of functions that take a single argument.  Takes a
          function, an optional hash scheme, and an optional cache. (See more
          below.)  Returns the input function, but imbues it with a cache
          object.  Memoization is a powerful optimization technique to
          avoiding making computationally expensive calls needlessly.
          `memoize` provides a no-fuss cache in memory without requring you to
          setup anything cumbersome, like a lookup table.

          **Arguments**



          Input Function (required) - This function must accept only a single
          argument.  `memoize` returns this function, but gives it a cache to
          remember past results.



          Hashing Scheme (optional) - The cache is a JavaScript object, where
          the results are stored as values... but we need a name to give the
          corresponding keys.  `memoize` needs a hash scheme so it can always
          lookup a result.  By default, `memoize` is unimaginiative and merely
          stringifies the function's input as the key.  In most cases, this
          should be good enough, but you can substitute a scheme of your
          choosing.  For example, if you wanted the keys to be rendered as
          hexidecimal strings:
        examples:
          code: >-
            # Just stick memoize before a function and cache answers for the
            future.

            double = memoize (x) -> 2 * x

            assert double(5) == 10


            # We can also pass a "preheated" cache to memoize.  Here we prove
            by caching

            # an incorrect answer.

            f = (x) -> 2 * x

            double = memoize f, null, {"5": 25}

            assert double(5) == 25  # Incorrect, but expected.


            #===========================================================================

            # That was simple enough, but lets prove that we're getting a
            performance

            # boost from memoize.  Here we define a function with a "sleep"
            duration we

            # artificially impose for simplicity.

            triple = memoize async (x) ->
              yield sleep 100
              3 * x

            # Run "triple", but record the execution duration.  If it is less
            than 100ms,

            # we've proved that the cached answer was used.

            call ->
              startTime = Date.now()
              result = yield triple 5
              duration = Date.now() - startTime
              assert result == 15
              assert duration >= 100 # Because of generator ping-pong, this is around 106ms.

              # Do it again!!  But this time, the cached answer will be accessed.
              startTime = Date.now()
              result = yield triple 5
              duration = Date.now() - startTime
              assert result == 15
              assert duration <= 100 # Never makes it to generator, this is around 0ms.
      - title: timer
        description: >-
          Execute a time-delayed function.  Takes an interval in microseconds
          and a function (the "action").  Returns a cancel function.  `timer`
          is a functional approach to JavaScript's native `setTimeout` and
          `clearTimeout`.

          Normally, when the timer reaches zero, the action executes.  But you
          can stop the timer and prevent the action from executing by calling
          the cancel function.  However, once the timer reaches zero, the
          cancel function is rendered useless.
        examples:
          code: >-
            # We need an action to put into "timer", but we'll cancel it
            before it runs.

            x = 5

            tooLong = -> x = x * 2

            cancel = timer 10000, tooLong


            # 10 seconds is too long to wait.  Cancel it!!

            cancel()

            assert x == 5   # We kept tooLong from executing.
      - title: sleep
        description: >-
          Perform a non-blocking wait before resuming execution.  Takes a
          duration in milliseconds.  Returns a promise that resolves after the
          given duration, resuming execution.  Because `sleep` non-blocking,
          other actions may take place while the generator that contains
          `sleep` is idle.
        examples:
          code: |-
            # Provide a containing generator for the sleep calls.
            call ->
              startTime = Date.now()
              yield sleep 100
              duration = Date.now() - startTime
              assert duration > 50  # Without "sleep", this would take fractions of a millisecond.
      - title: times
        description: >-
          Run a function N times.  Takes a function and the number of times
          you'd like it to run.  Returns an array containing the result of
          each function call.  `times` is curried.
        examples:
          code: >-
            x = 2

            square = -> x = x ** 2


            result = times square, 5

            assert.deepEqual result, [ 4, 16, 256, 65536, 4294967296 ] # That
            escalated quickly!!
      - title: benchmark
        description: >-
          Determine the execution time of a function.  Takes a function.
          Returns the time it took to complete in milliseconds.  This is a
          great little function for monitoring performance within your code.
          You can even use this in conjunction with `times` to benchmark a
          function over N repetitions.
        examples:
          code: |-
            # Simple function that just burns cycles.
            useless = ->
              for i in [0...1000000]
                y = 1 + i

            single = benchmark useless                 # Got around 30ms
            multiple = benchmark -> times(useless, 5)  # Got around 500ms

            assert 0 < single < multiple
      - title: empty
        description: >+
          Determine if a data structure contains no value.  Takes a JavaScript
          data structure.  Returns `true` if it contains "no value".



          For arrays and strings, this means that its length is zero.



          For an object, it means that `keys` returns an array of length zero.



          For any other value, it will return true unless it's falsey.


        examples:
          code: |-
            assert empty( [] )        == true
            assert empty( "" )        == true
            assert empty( {} )        == true
            assert empty( null )      == true
            assert empty( undefined ) == true

            assert empty( 1 )     == false
            assert empty( [1] )   == false
            assert empty( "abc" ) == false
            assert empty( a: 0 )  == false
            assert empty( true )  == false
            assert empty( false ) == false
      - title: length
        description: >-
          Return the length property of an object.  Takes a JavaScript data
          structure.  Returns the value of the length property, if it exists.
          If the length propery does not exist, an error is thrown.

          Working with lengths crops up so frequently, this function is
          included to better integrate it into functional programming.  We
          *were* tempted to add a variant for objects, but innumerable
          properties would yield potentially surprising results. Instead, just
          use `length keys object`, which is still much more readable than
          `Object.keys(foo).length`.  And, if you're just comparing to zero,
          use `empty`, which works on all data structures, including objects.
        examples:
          code: |-
            assert length([]) == 0
            assert length([1]) == 1
            assert length([1, 2]) == 2
            assert length([1, 2, 3]) == 3

            assert length("") == 0
            assert length("p") == 1
            assert length("pan") == 3
            assert length("panda") == 5
      - title: deepEqual
        description: >-
          Assess the equality of two data structures, and go beyond
          superficial comparison.  Takes two JavaScript data structures.
          Returns `true` if they are equal or `false` if they are not.

          JavaScript possesses the comparison operator `===`, which works for
          simple data structures, but fails for arrays and differently shaped
          objects.  `deepEqual` does the extra computation to determine if two
          values are truely equal.
        examples:
          code: >-
            a = [1, 2, 3, 4, 5]

            b = [1, 2, 3, 4, 5]

            assert (a == b) == false  # Really, JavaScript?  The comparison
            operator failed us.

            assert deepEqual a, b     # deepEqual saves the day.


            a =
              foo: 1
              bar: 2
              baz: 3

            b =
              bar: 2
              foo: 1
              baz: 3

            assert (a == b) == false  # The comparison operator failed us.

            assert deepEqual a, b     # Again, deepEqual saves the day.

- title: Process
  description: ''
  content:
  - title: Process Functions
    description: ''
    content:
    - title: abort
      description: >-
        End the current process.  Takes an optional message to output.
        Exits with status code `-1`.
      examples:
        code: |-
          console.log "You see this message."

          abort "Cap'n she can't hold any longer!"
          console.log "This will never be seen."
    - title: shell
      description: |
        Asynchronously execute a shell command. Takes a string containing a
        shell command.  Returns a promise that either *resolves* to a result
        object or *rejects* with an error.  The result object contains the
        properties `stdout` and `stderr`, the final results piped to the
        shell's Standard Output and Standard Error, respectively.

        `shell` makes use of the[ NodeJS `child_process` API][shell-0] to
        handle the system call separately and asynchronously.  Your
        JavaScript execution enters a non-blocking wait until the child
        process ends, and you have no access to the output until `shell`
        resolves.  Additionally, `shell` is based on [NodeJS's `exec`
        subcommand][shell-1], which returns a buffer of limited size (200
        kB).  If your shell command is long-running or returns a large
        amount of data it could trigger a maxBuffer exceeded error.  For
        these reasons, `shell` should only be used for short-lived processes
        that don't return much data.

      examples:
        code: >-
          # Assume that we're sitting in a directory with this structure:

          # index.coffee

          # data/

          #   panda.md

          #   bamboo.md


          {stdout} = yield shell "ls #{__dirname}/data"


          # Remember that we get a string back from shell.  ls returns a
          newline delimited

          # list of files, so we can parse the output string on that.

          files = stdout.split "\n"

          assert.deepEqual files, [ 'panda.md', 'bamboo.md', '' ]

- title: File System
  description: ''
  content:
  - title: File System Functions
    description: ''
    content:
    - title: read
      description: |
        Asynchronously read from a data source.  `read` is an overloaded
        function that operates on files and streams.  In both cases, `read`
        returns a promise that either *resolves* to a result or *rejects*
        with an error. Please see the applicable section below to see the
        respective inputs and outputs.

        **Files**

        Takes a file path and an optional string encoding.    The result is
        a promise resolving to a JavaScript `String` of the binary file's
        contents, encoded as specified.  `read` will not resolve until the
        entire file has been processed.  Until that time, you will not be
        able to access the result value.

        By default, `read` uses UTF-8 encoding on the binary data it finds.
        [NodeJS supports other encodings][read-0], including `hex`,
        `base64`, `ascii`, and `utf16le` (aka `ucs2`).

        Additionally, you may retrieve a raw `Buffer` of a file's contents
        by passing `null`, `undefined`, `binary`, or  `buffer` as the second
        argument.
      examples:
        code: >-
          # Assume "stream" is a readable stream containing UTF-8 encoded
          data.

          a = yield read stream

          assert a == "Pandas love bamboo."


          # Assume "stream64" is a readable stream containing base64 encoded
          data.

          b = yield read stream64, "base64"

          assert b == "Pandas love bamboo."


          c = yield read stream, "buffer"

          assert.deepEqual c, new Buffer("Pandas love bamboo.")
    - title: write
      description: >-
        Asynchronously write a UTF-8 string or data buffer to a file.  Takes
        a target path and string (or buffer) to be written.  Returns a
        promise that either *resolves* if the write is successful and
        complete or *rejects* with an error.  The resolved return value is
        `undefined`.  `write` will overwrite a file if one already exists at
        the target path.
      examples:
        code: |-
          # Store something unique in a file.
          currentTime = Date.now().toString()
          yield write "#{__dirname}/time.txt", currentTime

          # Read back the data and see if it worked.
          value = yield read "#{__dirname}/time.txt"
          assert value == currentTime
    - title: stat
      description: >-
        Asynchronously get the stat object for a file.  Takes a path.
        Returns promise that either *resolves* to a result object or
        *rejects* with an error.  The result object's properties match
        Unix's stat output for a file.
      examples:
        code: >-
          # Assume that we're in a directory that has this target file.

          result = yield stat "#{__dirname}/lines.txt"


          # Grab the keys of the result and compare them to the expected
          properties.

          resultKeys = keys result

          expectedKeys = [ 'dev', 'mode', 'nlink', 'uid', 'gid', 'rdev',
          'blksize',
            'ino', 'size', 'blocks', 'atime', 'mtime', 'ctime', 'birthtime' ]

          assert.deepEqual resultKeys, expectedKeys
    - title: exists
      description: >-
        Asynchronously check to see if a file exists.  Takes a path.
        Returns a promise that either *resolves* to a result or *rejects*
        with an error.  The result is a boolean, `true` if the file exists,
        `false` if it does not.
      examples:
        code: >-
          # Assume that we're in a directory that has the first file, but
          not the second.

          a = yield exists "#{__dirname}/lines.txt"

          b = yield exists "#{__dirname}/does-not-exist"


          assert a == true

          assert b == false
    - title: readDir / readdir
      description: >-
        Asynchronously retrieve the local filenames within a directory.
        Aliased as `readdir`.  Takes a path.  Returns promise that either
        *resolves* with a result or *rejects* with an error.  A successful
        result is an array of localized filenames at the target path.
        `readDir` does not discriminate between files and directories, so
        both will appear in the result array.
    - title: ls
      description: >-
        Asynchronously retrieve absolute pathnames for a directory's
        contents.  Takes a target path.  Returns a promise that either
        *resolves* with a result or *rejects* with an error.  A successful
        result is an array of absolute filenames at the target path.  `ls`
        does not discriminate between files and directories, so both will
        appear in the result array.
      examples:
        code: |-
          # Assume we're in a directory with the following tree:
          # app/
          #   index.coffee
          #   index.html
          # index.coffee
          # index.css
          # index.html

          files = yield ls __dirname
          expectedValues = [
            "#{__dirname}/app"
            "#{__dirname}/index.coffee"
            "#{__dirname}/index.css"
            "#{__dirname}/index.html"
          ]

          # Notice how the returned files and directory are alphabetized.
          assert.deepEqual files, expectedValues
    - title: lsR / lsr
      description: >-
        Asynchronously retrieve the absolute pathnames for a directory's
        contents, including a recursive search through sub-directories.
        Takes a target path.  Returns a promise that either *resolves* with
        a result or *rejects* with an error.   A successful result is an
        array of absolute paths.  `lsR` operates recursively and will return
        *every* file within the filesystem tree under the target path.
      examples:
        code: >-
          # Assume we're in a directory with the following tree:

          # app/

          #   index.coffee

          #   index.html

          # index.coffee

          # index.css

          # index.html


          files = yield lsR __dirname

          expectedValues = [
            "#{__dirname}/app/index.coffee"
            "#{__dirname}/app/index.html"
            "#{__dirname}/index.coffee"
            "#{__dirname}/index.css"
            "#{__dirname}/index.html"
          ]


          # Notice how the returned filenames are alphabetized, including
          within sub-directories.

          assert.deepEqual files, expectedValues
    - title: glob
      description: >-
        Asynchronously glob on a directory's contents.  Takes a glob pattern
        and a target path.  Returns a promise that either *resolves* with a
        result or *rejects* with an error.   A successful result is an array
        of absolute *file* paths.

        A glob is a shell pattern that allows you to target multiple
        filenames that match a string with the glob "wildcard" character.
        `glob` only matches on absolute paths, so you need the "Globstar"
        operator (`**`), which matches any parent directory, if you pass in
        a non-absolute path.  However, use with caution because `glob`
        recursively searches sub-directories for matches.

        `glob` discriminates between files and directories and only returns
        matches on files.  If `glob` finds no matching files, an empty array
        is returned.
      examples:
        code: >-
          # Assume we're in a directory with the following tree:

          # app/

          #   index.coffee

          #   index.html

          # index.coffee

          # index.css

          # index.html


          files = yield glob "#{__dirname}/*.coffee", __dirname

          expectedValues = [
            "#{__dirname}/index.coffee"
          ]

          assert.deepEqual files, expectedValues


          # With the Globstar, you get any file within the tree that
          matches.

          files = yield glob "**/*.coffee", __dirname

          expectedValues = [
            "#{__dirname}/app/index.coffee"
            "#{__dirname}/index.coffee"
          ]

          assert.deepEqual files, expectedValues


          # Match for everything (files only) in the top-level directory.

          files = yield glob "#{dirname}/*", __dirname

          expectedValues = [
            "#{__dirname}/index.coffee"
            "#{__dirname}/index.css"
            "#{__dirname}/index.html"
          ]

          assert.deepEqual files, expectedValues



          # Match everything, equivalent to "lsR".

          files = yield glob "**/*", __dirname

          expectedValues = [
            "#{dir}/app/index.coffee"
            "#{dir}/app/index.html"
            "#{dir}/index.coffee"
            "#{dir}/index.css"
            "#{dir}/index.html"]
          assert.deepEqual files, expectedValues


          # No matches.

          files = yield glob "**/signup*", dir

          expectedValues = []

          assert.deepEqual files, expectedValues
    - title: chDir / chdir
      description: >-
        Change your working directory.  Aliased as `chdir`.  Takes a path
        and an optional function.   See below for possible results:

        **Without Optional Function**

        When only passed a path, `chdir` returns a function that will
        restore the original working directory when called.

        **With Optional Function**

        When passed a function, `chdir` executes the function.  The working
        directory is altered for the duration of execution and restored when
        the function returns.  **IMPORTANT:** Do not rely on the automatic
        restoration feature when using asynchronous functions, since another
        function may also change the current directory.
      examples:
        code: >-
          # Assume we're in a directory with sub-directory "app".  Store the
          original cwd.

          cwd = process.cwd()


          # We can change the working directory.

          goBack = chdir "#{__dirname}/app"

          assert process.cwd() == "#{__dirname}/app"


          # Now, restore the working directory.

          goBack()

          assert process.cwd() == cwd


          # Using chdir with a function results in no change after
          executing.

          f = -> "foobar"

          chdir "#{__dirname}/app", f

          assert process.cwd() == cwd
    - title: mv
      description: >-
        Asynchronously move a file.  Takes a file's path and a destination
        path.  Returns a promise that either resolves on success or rejects
        with an error.  Execution enters a non-blocking wait until the move
        is complete.
      examples:
        code: >-
          # Assume we're in a directory with a file "first", and that it
          reads:

          # "Pandas love bamboo."


          yield mv "#{__dirname}/first", "#{__dirname}/second"


          # Check that the first file is gone.

          assert (yield exist "#{__dirname}/first") == false


          # Check that the data moved to the second file.

          data = yield read "#{__dirname}/second"

          assert newData == "Pandas love bamboo."
    - title: cp
      description: >-
        Asynchronously copy a file.  Takes a file's path and a destination
        path.  Returns a promise that either resolves on success or rejects
        with an error.  Execution enters a non-blocking wait until the copy
        is complete.
      examples:
        code: >-
          # Assume we're in a directory with a file "first", and that it
          reads:

          # "Pandas love bamboo."


          yield cp "#{__dirname}/first", "#{__dirname}/second"


          # Check that the first file is still there.

          assert (yield exist "#{__dirname}/first") == true


          # Check that the data was copied to the second file.

          data = yield read "#{__dirname}/second"

          assert newData == "Pandas love bamboo."
    - title: rm
      description: >-
        Asynchronously remove a file.  Takes a file's path.  Returns a
        promise that either resolves on success or rejects with an error.
        Execution enters a non-blocking wait until the deletion is complete.
      examples:
        code: |-
          # Assume we're in a directory with a file "test".
          yield rm "#{__dirname}/test"

          # Check that the file is gone.
          assert (yield exist "#{__dirname}/test") == false
    - title: rmDir / rmdir
      description: >-
        Asynchronously remove a directory.  Takes a directory's path.
        Returns a promise that either resolves on success or rejects with an
        error.  `rmDir` will fail if the target directory is not empty.
        Execution enters a non-blocking wait until the deletion is complete.
      examples:
        code: |-
          # Assume we're in a directory with a directory "test".
          yield rmDir "#{__dirname}/test"

          # Check that the directory is gone.
          assert (yield exist "#{__dirname}/test") == false
    - title: mkDir / mkdir
      description: >-
        Asynchronously create a directory.  Aliased as `mkdir`.  Takes a
        [mode][mkDir-0] (octal value only) and a path.  Returns a promise
        that either resolves on success or rejects with an error.  Assumes
        any intermediate directories in the path already exist.  Execution
        enters a non-blocking wait until the creation is complete.
    - title: mkDirP / mkdirp
      description: >-
        Asynchronously create a directory and any intermediaries.  Aliased
        as `mkdirp`.  Takes a [mode][mkDirP-0] (octal value only) and a
        path.  Returns a promise that either resolves on success or rejects
        with an error.  Will create the specified directory and any
        intermediate directories, as necessary. Execution enters a
        non-blocking wait until the creation is complete.
    - title: isDirectory
      description: >-
        Asynchronously discriminate between files and directories.  Takes a
        path.  Returns a promise that either resolves on success or rejects
        with an error.  Success is a boolean, `true` if the path names a
        directory, `false` if it does not.
    - title: isFile
      description: >-
        Asynchronously discriminate between files and directories.  Takes a
        path.  Returns a promise that either resolves on success or rejects
        with an error.  Success is a boolean, `true` if the path names a
        file, `false` if it does not.
