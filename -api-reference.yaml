- title: Core
  description: >-
    Module: [`fairmont-core`][core]

    The core functions are functions that provide the functional programming
    glue for JavaScript. Includes support for currying, partial application, and
    composition of functions.
  content:
    - title: Core Functions
      description: ''
      content:

        - title: noOp
          taking: "`variadic/any`"
          returning: "`undefined`"
          description: >-
            Does nothing. Mostly useful with combinators to express the
            equivalent of an empty `return` statement.
          examples:
            - code: |-
                assert.equal undefined, noOp true

        - title: identity
          description: >-
            Takes a value and returns it. Useful in conjunction with combinators
            when you don't want to transform a given value but simply return it
            unchanged.
          example:
            code: assert (identity 7) == 7
        - title: wrap
          description: >-
            Takes a value and returns a function that always returns the given
            value.
          example:
            code: |-
              f = wrap 7
              assert f() == 7
        - title: curry
          description: >+
            Convert a function taking N arguments into a function that:



            given M < N arguments, returns another (curried) function taking N -
            M arguments



            given N arguments, runs the given function


          example:
            code: |-
              slice = curry (begin, end, array) -> array.slice begin, end
              truncate = slice 0
              x = truncate 3, [1..5]
              assert x.length == 3
        - title: _
          description: >-
            Special value to allow for late-binding of an argument. See
            [`partial`](#partial).
        - title: substitute
          description: >-
            Given two arrays, substitute values from the second array for
            elements in the first array with the special value `_`.
          example:
            code: |-
              ax = substitute [1, _, 3], [2]
              assert ax[1] == 2
        - title: partial
          description: >-
            Take a function and an argument list and return another function
            that takes its arguments and concatenates them with the first
            argument list, first performing argument substitution (see
            [`substitute`](#substitute)).
          example:
            code: |-
              {pow} = Math
              square = partial pow, _, 2
              assert (square 3) == 9
        - title: flip
          description: Flip the arguments of the given function.
          example:
            code: |-
              pow = curry flip Math.pow
              square =  pow 2
              assert (square 3) == 9
        - title: compose
          description: >-
            Compose a list of functions, returning a new function.

            You can compose functions returning promises (defined as returning a
            value having a `then` property) and you'll get a promise back,
            resolving to the result of the composition.
          example:
            code: |-
              inverse = (x) -> 1/x
              square = (x) -> x * x
              inverseSquare = compose inverse, square
              assert inverseSquare 5 == 1/25
        - title: pipe
          description: >-
            Composition, except the functions arguments are in order of
            application.
          example:
            code: |-
              a = (x) -> x + "a"
              b = (x) -> x + "b"
              ab = pipe a, b
              assert (ab "S") == "Sab"
        - title: apply
          description: >-
            Call a function with the given arguments. Useful when composing
            operations on functions.
          example:
            code: 'assert (apply identity, 1) == 1'
        - title: spread
          description: >-
            Converts a function taking a list of arguments into a function
            taking an array.
          example:
            code: |-
              cat = (a, b) -> a + b
              catPair = spread cat
              assert (catPair ["a", "b"]) == "ab"
        - title: 'unary, binary, and ternary'
          description: >-
            Take a given function taking a variable number of arguments and
            return one taking 1, 2, or 3 arguments. Useful in conjuction with
            `curry`.
          example:
            code: |-
              f = -> a + b
              g = curry binary f
              a = g "a"
              assert (a "b") == "ab"
        - title: negate
          description: >-
            Take a given function and return a new function that passes its
            arguments to the given function and negates the return value.
          example:
            code: |-
              _false = -> false
              _true = negate _false
              assert _true()
- title: Reactive
  description: >-
    Module: [`fairmont-reactive`][reactive]

    Reactive programming functions provide support for reactive programming
    based on JavaScript iterators.
  content:
    - title: Iterators
      description: >-
        Iterators are [defined in ES6][]:


        An object is an iterator when it knows how to access items from a
        collection one at a time, while keeping track of its current position
        within that sequence. In JavaScript an iterator is an object that
        provides a next() method which returns the next item in the sequence.
        This method returns an object with two properties: done and value.


        In Fairmont, we refer to such an object, in general, as a _product_.
      content:
        - title: isIterable
          description: |-
            A simple predicate that returns true if the argument is iterable.
            This is simple enough: it should have a `Symbol.iterator` property.
            However, generators in Node don't look like iterables (yet?).
            So we also return true for generators.
          example:
            code: |-
              assert isIterable [1..5]
              assert !(isIteratable 7)
        - title: isIterator
          description: >-
            A predicate that returns true if the argument is an iterator.

            Iterators are iterable (that is, they have a `Symbol.iterator`
            property) and also have a `next` property whose value is a function.
          example:
            code: 'assert isIterator iterator [1..5]'
        - title: iterator
          description: >-
            The `iterator` function takes a given value and attempts to return
            an iterator using the value.

            If the value is an iterable, we simply call the function returned by
            the `Symbol.iterator` property.

            If the value is a already an iterator, we simply return it.

            If the value is a generator, we call the generator.

            If the value is a function, we assign it's `Symbol.iterator` and
            `next` properties to itself, and return it. (This makes it possible
            to convert arbitrary functions into iterators, too.)
          example:
            code: |-
              i = iterator [1..5]
              assert 1 == value next i
              assert 2 == value next i
              assert 3 == value next i
              assert 4 == value next i
              assert 5 == value next i
              assert isDone next i
        - title: next
          description: >-
            Given an iterator or reactor, return a product. Equivalent to
            calling `i.next()` for a given iterator `i`.
        - title: value
          description: >-
            Returns the `value` property from a product. Equivalent to calling
            `x.value` for a given object `x`.
        - title: isDone
          description: >-
            Returns the `done` property from a product. Equivalent to calling
            `x.done` for a given object `x`.
    - title: Reactors
      description: >-
        Reactors are Fairmont's term for asynchronous iterators.

        Asynchronous iterators are an ES7 proposal.

        Instead of returning products, asynchronous iterators (reactors) return
        Promises that resolve to products (objects with `done` and `value`
        properties).
      content:
        - title: isReagent
          description: >-
            Analogous to `isIterable`.

            A predicate that returns true if its operand is an asynchronous
            iterator.

            Specifically, returns true if the `Symbol.asyncIterator` property is
            defined and is a function.

            Since reactors are based on an ES7 proposal, there are no built-in
            types that are asynchronous iterables. Fairmont provides a variety
            of functions for adapting values to reactors. See `reactor`.
          example:
            description: >-
              In this example, `events` is a function that takes an event
              producer and returns a reactor whose products are the given event.
              See [`events`](#events).
            code: |-
              button[Symbol.asyncIterator] = -> events "click", button
              assert isReagent button
        - title: isReactor
          description: >-
            Analogous to `isIterator`.

            A predicate that returns true if its operand is a reactor.

            Reactors are reagents (that is, they have a `Symbol.asyncIterator`
            property) and also have a `next` property whose value is a function.
          example:
            description: >-
              In this example, `events` is a function that takes an event
              producer and returns a reactor whose products are the given event.
              See [`events`](#events).
            code: |-
              r = (events "click", button)
              assert isReactor r
        - title: reactor
          description: >-
            Analogous to `iterator`. The `reactor` function takes a given value
            and attempts to return an reactor using the value.

            If the value is a reagent, we simply call the function returned by
            the `Symbol.asyncIterator` property.

            If the value is already a reactor, we simply return it.

            If the value is a function, we assign its `Symbol.asyncIterator` and
            `next` properties to itself, and return it. (This makes it possible
            to convert arbitrary functions into reactors, too.)

            If you want to use a generator function as an semi-coroutine, simply
            pass it in via the [`async`](#async) helper function to convert it
            into a promise-returning function, and then call `reactor` with the
            resulting function.
          example:
            description: >-
              In this example, `events` is a function that takes an event
              producer and returns a reactor whose products are the given event.
              See [`events`](#events).
            code: |-
              button[Symbol.asyncIterator] = -> events "click", button
              r = reactor button
              assert isReactor r
    - title: Observers
      description: >-
        Observer functions provide a way to asynchronously observe changes to
        values. The observer receives a temporally ordered sequence of
        notifications based on changes to the observed value.
      content:
        - title: observe
          description: >-
            Given an object or an array value, returns an event emitter that
            generates events when the value is changed.
          example:
            code: |-
              x = value: 7
              events = observe x
              events.on "change", (x) -> y = x.value
              x.value = 3
              assert y == 3
    - title: Adapters
      description: >-
        Adapters are functions that create iterators or reactors (aka,
        producers) from an existing value, like an Array or an event emitter.
      content:
        - title: producer
          description: >-
            Given a producible (that is, an iterable or reagent), or a Promise
            that resolves into a producible, returns a corresponding producer.
            Idempotent: if the operand is a already producer, it is simply
            returned.
          example:
            code: |-
              i = producer [1..5]
              assert (value next i) == 1
        - title: pull
          description: >-
            Given an iterator whose product values are Promises, returns a
            reactor. This is useful if an iterator is used in combination with
            an asynchronous function.
          example:
            description: >-
              Let's suppose we want a function that will convert an iterator
              that produces pathnames into a reactor producing hashes for the
              contents of the corresponding files. We might implement it like
              this.
            code: |-
              hashFiles = (pathnames) ->
                flow [
                  pathnames
                  map (pathname) -> read pathname
                  map (promise) ->
                    promise.then (content) -> md5 content
                ]
        - title: combine
          description: >-
            Given two or more producers, combines them into a single producer
            whose products are those of the given producers in aggregate.
          example:
            description: >-
              In the example below, `updates` is an array of reactors producing
              update functions, perhaps in response to `change` events for
              fields of a form.
            code: |-
              go [
                combine updates...
                map (update) -> update data
              ]
        - title: repeat
          description: >-
            Given a value, returns an iterator that always produces that value.
            Analogous to `wrap`for an iterator.
          example:
            code: |-
              alwaysTrue = repeat true
              assert alwaysTrue.next()
        - title: events
          description: >-
            Given an event name and an event emitter, returns a reactor whose
            products are the events corresponding to the given event name. You
            can also pass in a dictionary of event names, which makes it
            possible to specify error and end event names. Otherwise, these
            default to `error` and `end`.
          example:
            code: 'clickStream = events "click", button'
        - title: stream
          description: >-
            Given a stream object, returns a reactor whose products correspond
            to those of the stream. This is useful for treating a stream as a
            reactor.
          example:
            code: |-
              tokens = fold cat, [], [
                stream fs.createReadStream path
                map (chunk) -> chunk.split /\s+/
              ]
        - title: flow
          description: >-
            Given an producer and a list of functions, composes the functions
            (via [`pipe`](#pipe)) and then invokes the resulting function with
            the producer, returning another producer.
          example:
            code: |-
              squares = (numbers) ->
                flow [
                  numbers
                  map (n) -> n * n
                ]

              i = squares [1..5]
              assert (value next i) == 1
              assert (value next i) == 4
              assert (value next i) == 9
              assert (value next i) == 16
              assert (value next i) == 25
              assert isDone i
    - title: Filters
      description: Filters transform producers into other producers.
      content:
        - title: map
          description: >-
            Given a unary function and a producer, returns a new producer whose
            products are obtained by applying the function to the products of
            the original producer.
          example:
            code: |-
              i = map Math.sqrt, [1,4,9,16,25]
              assert (value next i) == 1
              assert (value next i) == 2
              assert (value next i) == 3
              assert (value next i) == 4
              assert (value next i) == 5
              assert isDone i
        - title: accumulate
          description: >-
            Given a binary function, an initial value, and a producer, returns a
            new producer whose products are obtained by applying the function to
            a running (accumulated) value and the products of the original
            producer.

            This works like [`reduce`](#reduce) except it produces the values
            returned by the reduce function instead of just the final value.
          example:
            code: |-
              i = accumulate add, 0, [1..5]
              assert (value next i) == 1
              assert (value next i) == 3
              assert (value next i) == 6
              assert (value next i) == 10
              assert (value next i) == 15
              assert isDone i
        - title: select/filter
          description: >-
            Given a function and a producer, return a producer whose products
            are obtained by applying the function to the products of the
            original producer until it finds one for which the function return
            true.
          example:
            code: |-
              i = select odd, [1..5]
              assert (value next i) == 1
              assert (value next i) == 3
              assert (value next i) == 5
              assert isDone i
        - title: reject
          description: >-
            Given a function and a producer, return a producer whose products
            are obtained by applying the function to the products of the
            original producer until it finds one for which the function return
            false. This is the complement to [`select`](#select).
          example:
            code: |-
              i = reject odd, [1..5]
              assert (value next i) == 2
              assert (value next i) == 4
              assert isDone i
        - title: project
          description: >-
            Given a property specifier (see [`property`](#property)) and a
            producer, return a producer whose products are obtained by taking
            the given property from the product values of the original producer.
            Equalent to `map (property specifier)`.
          example:
            code: |-
              i = project ["name", "first"], people
              assert (value next i) == "Jack"
              assert (value next i) == "Jill"
        - title: compact
          description: >-
            Given a producer, returns a producer whose products are the products
            from the original producer with defined values. Equivalent to
            `select isDefined`.
          example:
            code: |-
              i = compact [1, undefined, 2, undefined, 3]
              assert (value next i) == 1
              assert (value next i) == 2
              assert (value next i) == 3
              assert isDone i
        - title: partition
          description: >-
            Given an integer and a producer, returns a producers whose products
            are arrays of products from the original producer, whose length is
            equal to (or less than, for the last product) the given integer.
          example:
            code: |-
              i = partition 2, [1..10]
              assert (first value next i) == 1
              assert (first value next i) == 3
              assert (first value next i) == 5
              assert (first value next i) == 7
              assert (first value next i) == 9
              assert isDone i
        - title: take
          description: >-
            Given a function and a producer, return a producer whose products
            are those of the original producer, until the given function returns
            false when applied to the products.
          example:
            code: |-
              i = take ((n) -> n <= 5), [1..10]
              assert (value next i) == 1
              assert (value next i) == 2
              assert (value next i) == 3
              assert (value next i) == 4
              assert (value next i) == 5
              assert isDone i
        - title: takeN
          description: >-
            Given an integer _n_ and a producer, returns a producer whose
            products are the first _n_ products of the original producer.
          example:
            code: |-
              i = takeN 5, [1..10]
              assert (value next i) == 1
              assert (value next i) == 2
              assert (value next i) == 3
              assert (value next i) == 4
              assert (value next i) == 5
              assert isDone i
        - title: where
          description: >-
            Given a query _q_ and a producer _p_, equivalent to `select query q,
            p`. See also: [`query`](#query).
          example:
            code: |-
              i = where length: 3, ["one", "two", "three"]
              assert (value next i) == "one"
              assert (value next i) == "two"
              assert isDone i
        - title: lines
          description: >-
            Given a producer whose products are strings, returns a producer
            whose products are the strings of the original producer, delimited
            by newlines.
          example:
            description: >-
              Define a functon that computes the average line length of a given
              file.
            code: |-
              averageLineLength = (path) ->
                average [
                  stream create fs.createReadStream path
                  lines
                  project "length"
                ]
        - title: tee
          description: >-
            Given a function and a producer, returns a producer whose products
            are those of the original producers. The given function is also
            applied to the original products. This function is like `map` except
            that it doesn't return the result of applying the function to the
            original product, it just returns the product. This is useful if you
            want to use the product more than once within a flow.
          example:
            description: >-
              Here's an HTTP server that passes a request context to a handler
              and then logs it in a fashion similar to Express/Connect
              middleware.
            code: |-
              go [
                events "request", server
                map spread (request, response) -> {request, response}
                tee (context) -> handler context
                map spread logger
              ]
        - title: throttle
          description: >-
            Given a integer specifying an interval in milliseconds and reactor,
            returns a reactor whose product are those of the original reactor,
            provided that the interval between any consecutive products is
            greater than the given interval. Products are discarded until the
            interval is reached or exceeded.
          example:
            description: >-
              Here is a file update watcher that ignores updates that occur
              close together.
            code: |-
              watch = (path, interval=3000) ->
                go [
                  events "change", fs.watch path
                  throttle interval
                ]
        - title: pump
          description: >-
            Given a stream and a producer, returns a producer whose products are
            the stream after writing the product of the original producer to the
            stream.
          example:
            description: Here is a simple echo server.
            code: |-
              go [
                events name: "connection", end: "close",
                  net.createServer().listen(1337)
                map (s) ->
                  go [
                    stream s
                    pump s
                  ]
              ]
        - title: zip
          description: >-
            Given a function and two producers, return a producer whose products
            are obtained by applying the given function to the products of the
            original producer.
    - title: Reducers
      description: >-
        Some functions _reduce_ an iterator into another value. Once a reduce
        function is introduced, the associated iterator functions will run.
      content:
        - title: fold/reduce
          description: >-
            Given a function, an initial value, and a producer, reduce the
            producer to a single value, ex: sum a list of integers.
          example:
            code: 'assert (reduce add, 0, [1..5]) == 15'
        - title: foldr/reduceRight
          description: >-
            Given an initial value, a function, and a producer, reduce the
            producer to a single value, ex: sum a list of integers, starting
            from the last (or rightmost) value.
          example:
            code: 'assert (foldr add, "", "panama") == "amanap"'
        - title: collect
          description: 'Given a producer, collect its product values into an array.'
          example:
            code: |-
              results = collect accumulate add, 0, [1..5]
              assert results[0] == 1
              assert results[0] == 3
              assert results[0] == 6
              assert results[0] == 10
              assert results[0] == 15
              assert results.length == 5
        - title: each
          description: >-
            Given a function _f_ and a producer _p_, equivalent to `start map f,
            p`. Useful for applying a function to a producer without collecting
            the results.
          example:
            code: 'each ((value) -> console.log value), [1..5]'
        - title: start
          description: >-
            Given a reactor, calls `next` until the reactor is exhausted. (That
            is, it's products' `done` property returns true.) Does not return a
            value.
          example:
            code: 'start map log, events'
        - title: any
          description: >-
            Given a function and a producer, return true if the given function
            returns true for any product value.
          example:
            code: 'assert any odd, [1..5]'
        - title: all
          description: >-
            Given a function and a producer, return true if the given function
            returns true for all the product values.
          example:
            code: 'assert all ((n) -> n <= 5), [1..5]'
        - title: assoc
          description: >-
            Given an producer whose products are associative pairs, return an
            object whose keys are the first element of the pair and whose values
            are the second element of the pair.
          example:
            code: >-
              person = assoc [["name", "Long John Silver"], ["occupation"],
              "Pirate"]]

              assert person.name == "Long John Silver" &&
                person.occupation == "Pirate"
        - title: flatten
          description: >-
            Given a producer whose product values may themselves be producers,
            return an array whose elements are the products of a depth-first
            traversal of the resulting producer tree.
          example:
            code: |-
              values = (flatten [1, [2, 3], 4, [5, [6, 7]]])
              assert values[0] == 1
              assert values[0] == 2
              assert values[0] == 3
              assert values[0] == 4
              assert values[0] == 5
              assert values[0] == 6
              assert values[0] == 7
              assert (length values) == 7
        - title: sum
          description: >-
            Given a producer _p_ whose products are numbers, return their sum.
            Equivalent to `fold add, 0`.
          example:
            code: 'assert (sum [1..5]) == 15'
        - title: average
          description: >-
            Given a producer _p_ whose products are numbers, return their
            average.
          example:
            code: 'assert (average [1..5]) == 3'
        - title: join
          description: >-
            Given a producer whose products are strings, concatenate the
            strings. Unlike `Array::join`, this function does not delimit the
            strings. See also: `delimit`.

            This is here instead of in [String Functions](./string.litcoffee) to
            avoid forward declaring `fold`.
          example:
            code: assert (join w "one two three") == "onetwothree"
        - title: delimit
          description: >-
            Given a delimiter and a producer whose products are strings,
            concatenate the strings using the delimiter.

            Like `join`, except that it each string is separated with the
            delimiter. Similar to `Array::join`, except there's no default
            delimiter and the function is curried. Calling `delimit ' '` is the
            same as calling `Array::join` with no delimiter argument.
          example:
            code: 'assert (delimit ", ", w "one two three") == "one, two, three"'
- title: Helpers
  description: >-
    Module: [`fairmont-helpers`][helpers]

    Helpers are general utility functions that are here to make your life easier
    by removing some of the tedium involved with manipulating JavaScript data
    structures.  Functions in `fairmont-helpers` draw on superpowers in
    `fairmont-core`, making them composable with each other and other modules.
  content:
    - title: Array Functions
      description: ''
      content:
        - title: push
          description: >-
            Attach one or more elements to the right side of the given array.
            `push` takes a target array and N elements to attach.  `push`
            directly affects the target array as a side effect, while also
            returning the augmented array.

            Note that pushing an array onto an array results in a nested array.
            For ***joining*** arrays, you may use `cat` or CoffeeScript's splat
            operator.
          example:
            code: >-
              # Directly affects "fruits" without storing return value.

              fruits = ["apple", "blueberry"]

              push fruits, "strawberry"

              assert.deepEqual fruits, ["apple", "blueberry", "strawberry"]


              citrus = ["lemon", "lime"]

              push fruits, citrus

              assert.deepEqual fruits, ["apple", "blueberry", "strawberry",
              ["lemon", "lime"]]


              # push accepts more than one element.

              fruits = ["apple", "blueberry"]

              push fruits, "strawberry", citrus

              assert.deepEqual fruits, ["apple", "blueberry", "strawberry",
              ["lemon", "lime"]]


              # With CoffeeScript's splat operator, we may achieve array
              concatenation.

              fruits = ["apple", "blueberry"]

              push fruits, "strawberry", citrus...

              assert.deepEqual fruits, ["apple", "blueberry", "strawberry",
              "lemon", "lime"]
        - title: cat
          description: >-
            Takes two arrays and concatenates (joins) them.  Returns the new,
            single array.  The input arrays remain unchanged.
          example:
            code: |-
              fruits = ["apple", "blueberry"]
              citrus = ["lemon", "lime"]
              fruits = cat fruits, citrus
              assert.deepEqual fruits, ["apple", "blueberry", "lemon", "lime"]
        - title: slice
          description: >-
            Extract a subset of an array.  `slice` takes two numbers and an
            array.  The two numbers specify a start and end index for the
            desired sub-array within the input array.  Both indices are
            zero-based, inclusive on the start index, and exclusive on the end
            index.  `slice` returns a sub-array, as specified, while leaving the
            original array unchanged.

            `slice` may also be used with strings where it treats characters
            like members of an array.  `slice` returns a sub-string when working
            with strings.

            When specifying an end index in excess of the array's length, the
            sub-array will only extend to the end of the original array.  The
            end index is allowed to be negative, where it counts to the left
            from the end of the target array.  The start index must be smaller
            than the end index, except when the end index is negative.  Invalid
            indices cause `slice` to return an empty array.

            `slice` is curried, meaning that it returns a function when given an
            insufficient number of arguments.  This new function accepts the
            remaining arguments, see the "snip" example below.
          example:
            code: >-
              fruits = ["apple", "blueberry", "lemon", "lime", "orange",
              "strawberry", "cherry"]

              citrus = slice 2, 5, fruits

              assert.deepEqual citrus, ["lemon", "lime", "orange"]


              # Works on strings too.

              string = "supercalifragilisticexpialidocious"

              sub_string = slice 9, 20, string

              assert.deepEqual sub_string, "fragilistic"


              # Even if the end index is large, slice can only go as far the
              original array.

              long = slice 2, 10, fruits

              assert.deepEqual long, ["lemon", "lime", "orange", "strawberry",
              "cherry"]


              # The end index may be negative, counting from the right side of
              the original array.

              negative = slice 1, -2, fruits

              assert.deepEqual negative, ["blueberry", "lemon", "lime",
              "orange"]




              # Slice is curried, so it returns a function when you don't pass
              all three arguments.

              snip = slice 2, 5


              # And the new function takes only the remaining argument (or
              arguments).

              f = snip fruits

              assert.deepEqual f, ['lemon', 'lime', 'orange']


              # Just to be clear, snip is reusable as a function.

              ax = [1..10]

              bx = [11..20]


              a = snip ax

              b = snip bx

              assert.deepEqual a, [ 3, 4, 5 ]

              assert.deepEqual b, [13, 14, 15]
        - title: 'first, second, third, fourth, fifth'
          description: >-
            Takes an array or string.  For arrays, returns the first, second,
            third, fourth, and fifth element, respectively.  For strings,
            returns the first, second, third, fourth, and fifth character,
            respectively.  Returns `undefined` for objects and numbers.
          example:
            code: >-
              fruits = ["apple", "blueberry", "lemon", "lime", "orange",
              "strawberry", "cherry"]

              string = "supercalifragilisticexpialidocious"


              fruit = first fruits

              assert.deepEqual fruit, "apple"


              char = second string

              assert.deepEqual char, "u"


              fruit = third fruits

              assert.deepEqual fruit, "lemon"


              char = fourth string

              assert.deepEqual char, "e"


              fruit = fifth fruits

              assert.deepEqual fruit, "orange"
        - title: nth
          description: >-
            A generalization of `first`, `second`, etc, from above.  `nth` takes
            an index and either an array or string.    Returns the element (or
            character) at the specified index, however the index is one-based.
            This stands in contrast to the usual, zero-based index in
            JavaScript.  `nth` returns `undefined` for objects and numbers.
          example:
            code: >-
              fruits = ["apple", "blueberry", "lemon", "lime", "orange",
              "strawberry", "cherry"]

              string = "supercalifragilisticexpialidocious"


              fruit = nth 3, fruits

              assert.deepEqual fruit, "lemon"


              char = nth 22, string

              assert.deepEqual char, "x"
        - title: last
          description: >-
            Takes an array or string.  For arrays, `last` returns the last
            element.  For strings, `last` returns the last character.  `last`
            returns `undefined` for objects and numbers.
          example:
            code: >-
              fruits = ["apple", "blueberry", "lemon", "lime", "orange",
              "strawberry", "cherry"]

              string = "supercalifragilisticexpialidocious"


              fruit = last fruits

              assert.deepEqual fruit, "cherry"


              char = last string

              assert.deepEqual char, "s"
        - title: rest
          description: >-
            Takes an array or string.  For arrays, `rest` returns a sub-array
            containing all elements *except* the first.  For strings, `rest`
            returns a sub-string containing all characters *except* the first.
            `rest` returns `undefined` for objects and numbers.
          example:
            code: >-
              fruits = ["apple", "blueberry", "lemon", "lime", "orange",
              "strawberry", "cherry"]

              string = "supercalifragilisticexpialidocious"


              bunch = rest fruits

              assert.deepEqual bunch, ["blueberry", "lemon", "lime", "orange",
              "strawberry", "cherry"]


              char = rest string

              assert.deepEqual char, "upercalifragilisticexpialidocious"
        - title: includes
          description: >-
            Check if an element is a member of an array.  Takes a candidate
            element and the array to test.  Returns `true` or `false`.
          example:
            code: >-
              fruits = ["apple", "blueberry", "lemon", "lime", "orange",
              "strawberry", "cherry"]


              is_present = includes "lemon", fruits

              assert.deepEqual fruit, true


              is_present = includes "pear", fruits

              assert.deepEqual fruit, false
        - title: unique
          description: >-
            Strip repeated elements out of an input.  Takes a single array or
            string as input.  For arrays, `unique` returns a new array
            containing only the unique members of the original.  For strings,
            `unique` returns a new array containing unique *characters* from the
            original string.  For inputs that are a JavaScript object or number,
            `unique` returns an empty array.  In all cases, the original input
            remains unchanged.
          example:
            code: >-
              fruits = ["apple", "lemon", "apple", "lime", "apple", "orange",
              "apple", "cherry"]

              string = "supercalifragilisticexpialidocious"


              fruit = unique fruits

              assert.deepEqual fruit, ["apple", "lemon", "lime", "orange",
              "cherry"]


              letters = unique string

              assert.deepEqual letters, ['s', 'u', 'p', 'e', 'r', 'c', 'a', 'l',
              'i', 'f', 'g', 't', 'x', 'd', 'o']
        - title: uniqueBy
          description: >-
            A generalized version of [`unique`](#unique).  `uniqueBy` takes an
            input function, `f()`, and an array, `a`.  `f()` is mapped on the
            members of `a`, transforming them, ie `f()` should be designed to
            act upon one element at a time.   `uniqueBy` returns a new array
            containing only the unique members ***after*** being transfomred by
            `f()`.
          example:
            code: >-
              numbers = [2, 3, 6, 9, 10, 14, 15, 18, 21, 22, 26, 27, 30, 33, 34,
              39, 45, 51]

              f = (x) -> if x % 2 == 0 then x * 3 else x * 2


              output = uniqueBy f, numbers

              assert.deepEqual output, [6, 18, 30, 42, 54, 66, 78, 90, 102]
        - title: dupes
          description: >-
            Locate duplicated, or repeated, elements in an array.  Takes a
            single array or string as input.  For arrays, `dupes` returns a new
            array containing only the members of the original that appear more
            than once.  For strings, `dupes` returns a new array containing
            ***characters*** from the original string that appear more than
            once.  For inputs that are a JavaScript object or number, `dupes`
            returns an empty array.  In all cases, the original input remains
            unchanged.
          example:
            code: >-
              fruits = ["apple", "lemon", "apple", "lime", "apple", "orange",
              "apple", "cherry"]

              string = "supercalifragilisticexpialidocious"


              fruit = dupes fruits

              assert.deepEqual fruit, ["apple"]


              letters = dupes string

              assert.deepEqual letters, ['u', 'p', 'e', 'r', 'a', 'l', 's', 'c',
              'i', 'o']
        - title: union
          description: >-
            Generate the [set union][set-union] of two arrays.  `union` takes
            two arrays and returns a new, concatenated array with any duplicate
            elements removed.  The original arrays remain unchanged.
          example:
            code: >-
              fruits1 = ["apple", "lemon", "apple", "lime", "apple", "orange",
              "apple", "cherry"]

              fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
              "apple", "cherry"]


              output = union fruits1, fruits2

              assert.deepEqual output, ['apple', 'lemon', 'lime', 'orange',
              'cherry', 'pear', 'mango', 'kiwi']


              letters = dupes string

              assert.deepEqual letters, ['u', 'p', 'e', 'r', 'a', 'l', 's', 'c',
              'i', 'o']
        - title: intersection
          description: >-
            Generate the [set intersection][set-intersection] of two arrays.
            `intersection` takes two arrays and returns a new, single array of
            elements present in both arrays.  This includes repeated elements if
            and only if they are repeated in both inputs.  The original arrays
            remain unchanged.
          example:
            code: >-
              fruits1 = ["apple", "lemon", "apple", "lime", "apple", "orange",
              "apple", "cherry"]

              fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
              "apple", "cherry"]


              output = intersection fruits1, fruits2

              assert.deepEqual output, ["apple", "lemon", "lime", "apple",
              "cherry"]
        - title: difference
          description: >-
            Generate the [symmetric difference][symmetric-difference] of two
            arrays.  `difference` takes two arrays and returns a new, single
            array of elements that are not shared between the inputs.
            Additionally, the output array presents only ***unique*** elements,
            removing duplicates.  The original arrays remain unchanged.
          example:
            code: >-
              fruits1 = ["apple", "orange", "lemon", "apple", "lime", "apple",
              "orange", "apple", "cherry"]

              fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
              "apple", "cherry", "mango"]


              output = difference fruits1, fruits2

              assert.deepEqual output, ["orange", "pear", "mango", "kiwi"]
        - title: complement
          description: >-
            Generate the [relative complement][relative-complement] of an array
            with respect to another.  `complement` takes two arrays, `a` and
            `b`, and returns a new array of elements that are present in `a` but
            not `b`.  This includes repeated elements if `a` has duplicates.
            The original arrays remain unchanged.
          example:
            code: >-
              fruits1 = ["apple", "orange", "lemon", "apple", "lime", "apple",
              "orange", "apple", "cherry"]

              fruits2 = ["pear", "apple", "mango", "kiwi", "lemon", "lime",
              "apple", "cherry", "mango"]


              # Note that order matters.  Relative complement is not
              associative.

              output = complement fruits1, fruits2

              assert.deepEqual output, ["orange", "orange"]


              output = complement fruits2, fruits1

              assert.deepEqual output, ["pear", "mango", "kiwi", "mango"]
        - title: remove
          description: >-
            Destructively remove an element from an array. `remove` takes a
            candidate element and array.  `remove` returns the element if it is
            present in the array.  If it is not present, `remove` returns
            `null`.

            The input array is altered by `remove` if the element is present.
            If there is more than one instance of the element within the array,
            only the first instance is removed.
          example:
            code: >-
              fruits = ["apple", "orange", "lemon", "apple", "lime", "apple"]


              output = remove "orange", fruits

              assert.deepEqual output, "orange"

              assert.deepEqual fruits, ["apple", "lemon", "apple", "lime",
              "apple"]


              output = remove "apple", fruits

              assert.deepEqual output, "apple"

              assert.deepEqual fruits, ["lemon", "apple", "lime", "apple"]


              output = remove "orange", fruits

              assert.deepEqual output, null

              assert.deepEqual fruits, ["lemon", "apple", "lime", "apple"]
        - title: shuffle
          description: >-
            Randomize the order of elements within an array.  `shuffle` takes an
            array and returns a new array where all values have been ordered
            pseudorandomly.  Please note that `shuffle` is ***guaranteed*** to
            produce a different ordering (which is a non-random behavoir).
            Specifically, `shuffle` uses the [Fisher-Yates algorithm][shuffle-1]
            as adapted from [this CoffeeScript Cookbook recipe][shuffle-2].
          example:
            code: |-
              numbers = [1..10]

              scrambled = shuffle numbers
              assert.notDeepEqual numbers, scrambled
              # Example result, [ 5, 2, 4, 9, 8, 10, 1, 7, 3, 6 ]
        - title: range
          description: >-
            Generate an array of ordered integers.  `range` takes two numbers
            specifying the start and end of the titular range.  `range` returns
            a new array containing an ordered list, either ascending or
            descending, of all integers from the start value to end value,
            inclusive.  When the start and end values are identical, an array
            with one element is returned.  Invalid input causes `range` to
            return an empty array.
          example:
            code: |-
              output = range 1, 5
              assert.deepEqual output, [1, 2, 3, 4, 5]

              output = range 5, 1
              assert.deepEqual output, [5, 4, 3, 2, 1]

              output = range 5, 5
              assert.deepEqual output, [ 5 ]

              output = range 1, "foobar"
              assert.deepEqual output, []
    - title: Hashing/Encoding Functions
      description: ''
      content:
        - title: md5
          description: >-
            Generate the [MD5 hash][md5-1] of a string.  `md5` takes a UTF-8
            encoded string.  Returns a the hash result of the MD5 message digest
            algorithm.  The hash is 128-bit value, represented as a stringified
            32 digit hexidecimal number.

            The MD5 algorithm is deterministic, meaning that a given input
            corresponds to a specific output and will always return the same
            hash.  The MD5 algorithm's output is fixed length, meaning that
            regardless of the input, the output hash will always be a 32 digit
            hexidecimal string.

            `md5` effectively assigns a value to each input string, and because
            there are 2^128 possible outcomes (340 trillion trillion trillion),
            it is incredibly unlikely that any two inputs will produce the same
            hash.  This uniqueness allows you to do useful things, however
            ***the MD5 algorithm has been proven to be cryptographically
            insecure***.  Therefore, while `md5` is a useful function, you
            ***MUST NOT*** ever use this function as part of a security
            architecture.
          example:
            code: >-
              output = md5 "panda"

              assert output == "ce61649168c4550c2f7acab92354dc6e"


              # Putting in the same string will yield the same output.

              output = md5 "panda"

              assert output == "ce61649168c4550c2f7acab92354dc6e"


              # The output of md5 is always the same length.

              output = md5 "Regardless of the length of the input string, this
              MD5 function always returns a 32 digit hexidecimal number."

              assert output == "682f5e81981d68d2b196137042d17c79"
        - title: base64
          description: >-
            Convert a string to Base64 encoding.  `base64` takes an UTF-8
            encoded string.  Returns a string of the same content, but encoded
            in Base64.  Please note that this function ***does not*** produce a
            URL-safe string.  Please use `base64url` for that case.
          example:
            code: |-
              output = base64 "abc123!?$*&()'-=@~~"
              assert output == "YWJjMTIzIT8kKiYoKSctPUB+fg"
        - title: base64url
          description: >-
            Convert a string to a URL-safe variant of Base64 encoding.
            `base64url` takes an UTF-8 encoded string.  Returns a string of the
            same content, but encoded in a URL-safe variant of Base64, based on
            [RFC 4648's][base64url-1] "base64url" mapping.  The URL-safe variant
            avoids outputting `+`, `/`, or `=`, but is otherwise very similar to
            `base64`.
          example:
            code: |-
              output = base64url "abc123!?$*&()'-=@~~"
              assert output == "YWJjMTIzIT8kKiYoKSctPUB-fg"
    - title: Generators
      description: ''
      content:
        - title: call
          description: >-
            Execute a generator containing asynchronous instructions.  Takes a
            generator and is a pass-through for its return.

            ES6's introduction of generators offers a wonderful way to handle
            asynchronous methods.  A generator is any function with one or more
            `yield` operators, which is where the execution enters a
            non-blocking wait for the result.  However, we cannot use `yield`
            without a containing generator.  `call` is a convenience function
            that lets you to wrap your async code with a generator that
            immediately begins executing.
          example:
            code: >-
              # Putting in the asynchronous sleep is contrived, but it keeps
              this simple.

              call ->
                string = "panda"
                yield sleep 100
                assert string == "panda"
        - title: async
          description: >-
            Establish a reusable generator function by wrapping it in a
            promise.  Takes a generator and returns a promise that either
            ***resolves*** the return value or ***rejects*** with an error.

            ES6's introduction of generators offers a wonderful way to handle
            asynchronous methods.  A generator is any function with one or more
            `yield` operators, which is where the execution enters a
            non-blocking wait for the result.  The trick to writing asynchronous
            code that follows a synchronous pattern is to always pair the
            `yield` operator with a promise.

            That means when we write a generator that we'd like to reuse, we
            need to wrap it in a promise.  But it can be a burden to make your
            code promise aware.  Which is why Fairmont includes `async` as
            convenience function to handle all that for you.  As long as you
            include `yield`, you are free to write in a synchronous pattern.
            `async` will promisify your generator and allow you to continue the
            `yield` pattern throughout your callstack.
          example:
            code: >-
              # Putting in the asynchronous sleep is contrived, but it keeps
              this simple.

              square = async (x) ->
                yield sleep 100
                x**2

              call ->
                a = 2
                a = yield square a
                a = yield square a
                a = yield square a
                assert a == 256
    - title: Numeric Functions
      description: ''
      content:
        - title: 'gt, lt, gte, lte'
          description: Curries a value to allow future evaluation of relative value.
          example:
            code: |-
              recruits = add 5
              assert recruits 1 == 6
        - title: 'odd, even'
          description: Evaluates whether a value is odd or even.
          example:
            code: assert odd 5
        - title: Functions exported from Math
          description: |-
            #####min, max
            Gives the lowest or highest value in a set of numbers.
          example:
            code: 'assert pow(3, 3) == 27'
    - title: Object Functions
      description: ''
      content:
        - title: 'include, extend'
          description: >-
            Add the properties of one or more objects to another. Aliased as
            `extend`.  Takes a base object and N additional objects. `include`
            directly affects the base object as a side effect, while also
            returning the augmented object.  The additional objects (not the
            base object) remain unchanged.

            All properties that exist among the input objects will exist in the
            resultant object.  If a object property already exists, the last
            value entered will overwrite the previous.
          example:
            code: >-
              stats = {hp: 50, mp: 100}


              include stats, {stamina: 10, strength: 10}, {intelligence: 50,
              agility: 20}

              assert.deepEqual Object.keys(stats), ["hp", "mp", "stamina",
              "strength", "intelligence", "agility"]


              include stats, {stamina: 50}

              assert stats.stamina == 50
        - title: merge
          description: >-
            Create a new object by merging the properties of one or more objects
            together.  Takes N objects. Returns a new object containing the
            properties of all input objects.

            `merge` is a more generalized accumulation function that always
            returns a new object.  If a object property already exists in
            another object, the last value entered will overwrite the previous.
          example:
            code: >-
              stats = {hp: 50, mp: 100}


              stats = merge {hp: 50, mp: 100}, {stamina: 10, strength: 10},
              {intelligence: 50, agility: 20}

              assert.deepEqual Object.keys(stats), ["hp", "mp", "stamina",
              "strength", "intelligence", "agility"]
        - title: clone
          description: >-
            Perform a deep clone on an object. Takes an object and returns a new
            object copy.

            The algorithm for copying the object is taken from [The CoffeeScript
            Cookboox][clone-1].  `clone` uses a recursive process to copy nested
            properties, providing a *deep* clone.  When passed a non-object,
            `clone` will still return a copy of what it is passed.
          example:
            code: >-
              person =
                name: "Steve Jobs"
                address:
                  street: "1 Infinite Loop"
                  city: "Cupertino, CA"
                  zip: 95014
                birthdate: new Date 'Feb 24, 1955'
                regex: /foo.*/igm


              assert.notEqual  (clone person), person  # Because birthdate ==
              Date.getTime()

              assert.deepEqual (clone person), person


              assert (clone 1) == 1
        - title: property
          description: >-
            Extract a property from an object.  Takes a property name and a
            target object.  `property` returns the value of property on the
            target object.

            `property` is curried, meaning that it returns a function if you
            pass in only one of its two arguments.  This function will extract
            the set property from any target object.  These curried `property`
            invocations allow you to extract nested properties.
          example:
            code: |-
              a =
                foo: 1
                bar: 2
                baz:
                  foo: 2

              assert (property "foo", a) == 1

              # Curried invocations allow you to extract nested properties.
              bazFoo = (compose (property "foo"), (property "baz"))
              assert (bazFoo a) == 2
        - title: delegate
          description: >-
            Delegate from one object to another.  Takes two objects, the
            delegator and the delegatee.  `delegate` directly modifies the
            delegator's properties to reference the delegatee.

            Delegation is form of property inheritance separate from
            JavaScript's native prototype inheritance.  `delegate` allows any
            calls to the delegator's functions to reference their counterparts
            in the delgatee, if present.  Additionally, the delegator's context
            is shifted to the delgatee.

            The context shift is presented in the example below.  The second
            time we call `a.foo()` and access `this`, we are accessing the
            context of `b`, so `a.foo() == this.bar() == b.bar()`.
          example:
            code: |-
              a =
                foo: -> this.bar()
                bar: -> "This is a"

              b =
                bar: -> "This is b"

              assert a.foo() == "This is a"
              assert a.bar() == "This is a"

              delegate a, b
              assert a.foo() == "This is b"
              assert a.bar() == "This is b"
        - title: bind
          description: >-
            Define a new function based on a prototype function while keeping
            the instance's context.  Takes a function and a object instance.
            Returns a new function that shares its context with the original
            instance.

            By default, functions copied from prototype functions are bound to
            the outer, calling function's context.  `bind` overrides that
            behavior.  The new function's context will track the original
            instance's state.

            **Important** In the past, this did not always work for some
            natively implemented functions. That is hopefully no longer the
            case.
          example:
            code: >-
              this.x = 9

              foo =
                x: 81
                getX: -> this.x

              assert foo.getX() == 81     # accesses foo's internal context


              getX = foo.getX

              assert getX() == 9          # "this" refers to the outer or global
              context, not foo's


              boundGetX = bind getX, foo

              assert boundGetX() == 81    # Now, boundGetX's "this" is bound to
              foo's context


              foo.x = 11

              assert boundGetX() == 11    # Note that the context is *shared*,
              not copied.
        - title: detach
          description: >-
            Define a new function based on a prototype function, without taking
            any context.  Takes a function.  Returns a function that accepts a
            context followed by any arguments.

            By default, functions copied from prototype functions are bound to
            the outer, calling function's context.  `detach` overrides that
            behavior.  The new function is untethered from any context.  That
            gives you the control to pick what context should be applied with
            executing.

            **Important** In the past, this did not always work for some
            natively implemented functions. That is hopefully no longer the
            case.
          example:
            code: >-
              # Establishing an instance of prototype.

              foo = ->

              foo::x = 81

              foo::f = (y) -> this.x / y


              # Establishing secondary contexts.

              this.x = 9

              bar = x: 36


              # Once detached, we may apply the other contexts to "f".

              g = detach foo::f

              assert (g this, 3) == 3

              assert (g bar, 3) == 12



              # Detaching reflective functions creates a function that only
              needs one argument (a context).

              trim = detach String::trim

              assert (trim "  panda    ") == "panda"
        - title: properties
          description: >-
            Attach properties to a prototype.  Takes a target prototype and an
            object filled with the properties you wish to add.  `properties`
            directly adds the object to the target prototype.  Also, returns an
            array of statements associating the properties with the target
            prototype.

            Properties defined using `properties` are enumerable and
            configurable.
          example:
            code: >-
              # Define a prototype with a property that uses JavaScript's native
              getter and setter.

              class A
                properties @::,
                  foo:
                    get: -> @_foo
                    set: (v) -> @_foo = v

              # Test with an instance of "A".

              a = new A

              a.foo = "bar"

              assert a._foo == "bar"  # Proves the setter was used to create and
              set "_foo".
        - title: has
          description: >-
            Check if an object has a property.  Takes a property name and a
            target object.  Returns `true` if the property is present or `false`
            if it is not.  `has` is curried, meaning that if you pass it only a
            property, `has` return a function that takes only an object and
            checks for that property.
          example:
            code: >-
              panda =
                color: "black and white"
                limbs: 4

              fish =
                color: "silver"
                limbs: 0

              car =
                color: "red"
                wheels: 4

              assert (has "limbs", panda) == true

              assert (has "limbs", fish) == true

              assert (has "limbs", car) == false


              # has is curried, so we can create a function that always checks
              for the same property.

              wheelCheck = has "wheels"

              assert (wheelCheck panda) == false

              assert (wheelCheck fish) == false

              assert (wheelCheck car) == true
        - title: keys
          description: >-
            Get the keys for an object.  Takes an object.  Returns an array of
            the key names.
          example:
            code: |-
              panda =
                c: 3
                v: 1
                q: 12
                t: 10

              assert.deepEqual (keys panda), ["c", "v", "q", "t"]
        - title: values
          description: >-
            Get the values for an object.  Takes an object.  Returns an array of
            values for each key.
          example:
            code: |-
              panda =
                c: 3
                v: 1
                q: 12
                t: 10

              assert.deepEqual (values panda), [3, 1, 12, 10]
        - title: pairs
          description: >-
            Convert an object into association array.  Takes an object.  Returns
            a nested array that pairs the object's keys with its values.
          example:
            code: >-
              obj =
                a: 1
                b: 2
                c: 3

              output = pairs obj

              assert.deepEqual output, [["a", 1], ["b", 2], ["c", 3]]


              # pairs only works on the top level.  Nested structures will just
              end up in the association array.

              obj =
                a:
                  foo: 100
                  bar: 200
                b: 2
                c: 3

              output = pairs obj

              assert.deepEqual output, [ [ 'a', { foo: 100, bar: 200 } ], [ 'b',
              2 ], [ 'c', 3 ] ]
        - title: pick
          description: >-
            Filter the properties of an object on the result returned by a
            filter function.  Takes a function and a target object.  Returns a
            new object with only the filtered properties.  The original input
            object remains unchanged.

            The filter function processes the object's properties individually,
            accepting a given key and its value.  If the filter's return value
            is *truthy*, the property is added to the ***new*** object.  If the
            filter's return function is *falsey*, the property is omitted.  In
            this way, the new object is built up with only the desired
            properties.

            `pick` is curried.
          example:
            code: >-
              fruits =
                apples: 3
                oranges: null
                mangos: 12

              f = (key, value) -> value?            # Only if the value is
              truthy

              g = (key, value) -> value % 2 == 1    # Only if there is an odd
              number

              h = (key, value) -> key == "mangos"   # Really likes mangos?


              assert.deepEqual (pick f, fruits), {apples: 3, mangos: 12}

              assert.deepEqual (pick g, fruits), {apples: 3}

              assert.deepEqual (pick h, fruits), {mangos: 12}
        - title: omit
          description: >-
            The inverse of `pick`.  Filter the properties of an object on the
            result returned by a filter function.  Takes a function and a target
            object.  Returns a new object with only the filtered properties.
            The original input object remains unchanged.

            The filter function processes the object's properties individually,
            accepting a given key and its value.  If the filter's return value
            is *falsey*, the property is added to the ***new*** object.  If the
            filter's return function is *truthy*, the property is omitted.  In
            this way, the new object is built up with only the desired
            properties.

            `omit` is curried.
          example:
            code: >-
              fruits =
                apples: 3
                oranges: null
                mangos: 12

              f = (key, value) -> value?            # Only if the value is
              falsey

              g = (key, value) -> value % 2 == 0    # Only if there is an even
              number

              h = (key, value) -> key == "mangos"   # Really hates mangos?


              assert.deepEqual (omit f, fruits), {oranges: null}

              assert.deepEqual (omit g, fruits), {apples: 3}

              assert.deepEqual (omit h, fruits), {apples: 3, oranges: null}
        - title: query
          description: >-
            Check if an object has a given sub-object.  Takes a sub-object and a
            target object.  Returns `true` if the sub-object is found within the
            target or `false` if it is not.  `query` does not recurse beyond the
            first level of a nested target structure.  However, `query` can
            match on sub-objects with multiple members, including when the
            sub-object's shape is incongruent to the one within the target
            object.

            `query` may also be used with non-objects, however it only returns
            `true` on a `deepEqual` match, rather than checking for
            substructures within the target.

            `query` is curried.
          example:
            code: >-
              princess =
                name: "Aurora"
                alias:
                  name: "Sleeping Beauty"
                dwarves: 7
                enemy: "Maleficent"

              # Query will find an object within a larger object.

              assert query({name: "Aurora"}, princess) == true

              assert query({name: "Belle"}, princess) == false


              # But query cannot find the sub-object within a nested structure.

              findBeauty = query {name: "Sleeping Beauty"}

              assert findBeauty(princess) == false

              assert findBeauty(princess.alias) == true


              # If query is passed non-objects, it simply performs a deepEqual
              comparison.

              princesses = [
                "Ariel", "Aurora", "Belle", "Cinderella",
                "Jasmine", "Merida", "Mulan", "Pocahontas",
                "Rapunzel", "Snow White", "Tiana"
              ]


              assert query({name: "Aurora"}, princesses) == false

              assert query("Aurora", princesses) == false

              assert query(11, princesses.length) == true
        - title: 'toJSON, fromJSON'
          description: >-
            Stringify a JSON object and vice-versa.

            `toJSON` accepts a JavaScript data structure and an optional
            "pretty-print" boolean.  Returns a new string containing the data
            structure in JSON.  If the "pretty-print" value is set to `true`,
            the result will feature newline characters and 2-space indentation.
            If `false`, the result will feature no extra spaces or newlines. The
            "pretty-print" value defaults to false.
          example:
            code: >-
              mage = fromJSON
              '{"vitals":{"hp":50,"mp":100},"attributes":{"stamina":10,"strength":10,"intelligence":50,"agility":20}}'


              assert mage,
                vitals:
                  hp: 50
                  mp: 100
                attributes:
                  stamina: 10
                  strength: 10
                  intelligence: 50
                  agility: 20
    - title: String Functions
      description: ''
      content:
        - title: toString
          description: Converts a value to a string format.
          example:
            code: assert toString 12345 == "12345"
        - title: toUpper
          description: Makes all characters in a string upper-case.
          example:
            code: assert toUpper("allcaps") == "ALLCAPS"
        - title: toLower
          description: Makes all characters in a string lower-case.
          example:
            code: assert toLower ("LOWERCASE") == "lowercase"
        - title: plainText
          description: |-
            Convert an camel-case or underscore- or dash-separated string into a
            whitespace separated string.
          example:
            code: assert plainText ("Camel_under-dash") == "camel under dash"
        - title: capitalize
          description: Capitalize the first letter of a string.
          example:
            code: assert capitalize ("america") == "America"
        - title: titleCase
          description: Capitalize the first letter of each word in a string.
          example:
            code: assert capitalize ("los angeles") == "Los Angeles"
        - title: camelCase
          description: Convert a sequence of words into a camel-cased string.
          example:
            code: assert camelCase ("tostring") == "toString"
        - title: underscored
          description: Convert a sequence of words into an underscore-separated string.
          example:
            code: assert underscored ("one two three") == "one_two_three"
        - title: dashed
          description: Convert a sequence of words into a dash-separated string.
          example:
            code: assert dashed ("one two three") == "one-two-three"
        - title: htmlEscape
          description: >-
            Escape a string so that it can be embedded into HTML. Adapted from
            Mustache.js.
          example:
            code: >-
              assert htmlEscape ("<a href="www.msnbc.com">News Site</a>") ==
              "&lt;a href=&quot;www.msnbc.com&quot;&gt;News Site&lt;/a&gt;"
        - title: w
          description: >-
            Split a string on whitespace. Useful for concisely creating arrays
            of strings.
          example:
            code: |-
              tres = w ("1 2 3")
              console.log(tres)
              # Will print ['1', '2', '3']
              assert tres.length == 3
        - title: blank
          description: Check to see if a string has zero length.
          example:
            code: assert blank ("")
    - title: Type Functions
      description: ''
      content:
        - title: prototype
          description: >-
            Returns the prototype of the given value using
            `Object.getPrototypeOf`.
        - title: isPrototype
          description: >-
            Binary predicate for determining whether the given prototype is the
            prototype for the given value.
          example:
            code: 'assert isPrototype Number.prototype, 7'
        - title: isType
          description: Verifies whether a variable is a specified type.
          content:
            - title: 'Example:'
              description: ''
        - title: isTransitivePrototype
          description: >-
            Binary predicate for determining whether the given prototype is in
            the prototype chain for the given value.
          example:
            code: 'assert isTransitivePrototype Error.prototype, (new TypeError)'
        - title: isKind
          description: >-
            Binary predicate for determining whether the given type's
            `prototype` property is in the prototype chain for the given value.
          example:
            code: 'assert isKind Error, (new TypeError)'
        - title: instanceOf
          description: Wrapper around `instanceof` operator.
        - title: isNumber
          description: Verifies that an input has a numeric value.
          example:
            code: assert isNumber 7
        - title: isNaN
          description: Verifies whether a given value is `NaN`.
          example:
            code: assert !isNaN 7
        - title: isFinite
          description: ''
        - title: isInteger
          description: ''
        - title: isFloat
          description: |-
            Verifies that is an argument is a number of a specific type.
            Adapted from [StackOverflow][isFloat].
          example:
            code: assert isFloat 3.5
        - title: isBoolean
          description: Verifies that an argument is Boolean.
          example:
            code: assert isBoolean true
        - title: isDate
          description: Verifies that a variable contains a date.
          example:
            code: assert isDate (new Date)
        - title: isRegExp
          description: >-
            Verifies that an input is a regular expression. Regular expressions
            are used as a basis for string searches.
          example:
            code: assert isRegExp /\s/
        - title: isString
          description: Verifies that a variable contains a string of characters.
          example:
            code: assert isString "Hello"
        - title: isFunction
          description: >-
            Verifies that a variable is a function. A function takes one or more
            arguments as input and returns a value.
          example:
            code: |-
              func = (a) -> a*a
              assert isFunction func
        - title: isObject
          description: Verifies that a variable is an object.
          example:
            code: |-
              thing = {one: 1, two: 2}
              assert isObject thing
        - title: isArray
          description: Verifies that a value is an array.
          example:
            code: 'assert isArray [1, 2, 3, 4, 5]'
        - title: isDefined
          description: Verifies that a value exists.
          example:
            code: assert isDefined String
        - title: isGenerator
          description: >-
            Verifies that a variable is a generator. A generator can be used to
            systematically create iterators, with the subsequent steps built in
            ahead of time.

            Generators facilitate automation and simplify the task of creating
            iterators.
          example:
            code: |-
              count = () ->
                yield 1
                yield 2
                yield 3
              assert isGenerator count
        - title: isPromise
          description: >-
            Verifies that a variable is a promise. A promise is essentially a
            link in a chain of operations, that checks to see whether a given
            condition has been met. If the condition is fulfilled, it moves on
            to another designated process (generally another promise). If an
            unexpected result occurs, the promise is rejected and it moves on to
            a different designated outcome. Otherwise, a promise is in its
            pending state. In other words, promises have "then" functionality
            built in.

            Among other things, promises allow easier step by step error
            checking and an ordered series of events in asynchronous
            programming.
          example:
            code: |-
              promise () ->

              assert isPromise promise
    - title: Utility Functions
      description: >-
        "Utility" is a euphemism for this collection of functions that are very
        useful, but hard to categorize.  For the moment, this is a holding pen
        of sorts for functions that we're not sure what to do with.  As Fairmont
        grows and matures, these functions may be placed into another
        collection.
      content:
        - title: memoize
          description: >-
            Cache the results of functions that take a single argument.  Takes a
            function, an optional hash scheme, and an optional cache. (See more
            below.)  Returns the input function, but imbues it with a cache
            object.  Memoization is a powerful optimization technique to
            avoiding making computationally expensive calls needlessly.
            `memoize` provides a no-fuss cache in memory without requring you to
            setup anything cumbersome, like a lookup table.

            **Arguments**



            Input Function (required) - This function must accept only a single
            argument.  `memoize` returns this function, but gives it a cache to
            remember past results.



            Hashing Scheme (optional) - The cache is a JavaScript object, where
            the results are stored as values... but we need a name to give the
            corresponding keys.  `memoize` needs a hash scheme so it can always
            lookup a result.  By default, `memoize` is unimaginiative and merely
            stringifies the function's input as the key.  In most cases, this
            should be good enough, but you can substitute a scheme of your
            choosing.  For example, if you wanted the keys to be rendered as
            hexidecimal strings:
          example:
            code: >-
              # Just stick memoize before a function and cache answers for the
              future.

              double = memoize (x) -> 2 * x

              assert double(5) == 10


              # We can also pass a "preheated" cache to memoize.  Here we prove
              by caching

              # an incorrect answer.

              f = (x) -> 2 * x

              double = memoize f, null, {"5": 25}

              assert double(5) == 25  # Incorrect, but expected.


              #===========================================================================

              # That was simple enough, but lets prove that we're getting a
              performance

              # boost from memoize.  Here we define a function with a "sleep"
              duration we

              # artificially impose for simplicity.

              triple = memoize async (x) ->
                yield sleep 100
                3 * x

              # Run "triple", but record the execution duration.  If it is less
              than 100ms,

              # we've proved that the cached answer was used.

              call ->
                startTime = Date.now()
                result = yield triple 5
                duration = Date.now() - startTime
                assert result == 15
                assert duration >= 100 # Because of generator ping-pong, this is around 106ms.

                # Do it again!!  But this time, the cached answer will be accessed.
                startTime = Date.now()
                result = yield triple 5
                duration = Date.now() - startTime
                assert result == 15
                assert duration <= 100 # Never makes it to generator, this is around 0ms.
        - title: timer
          description: >-
            Execute a time-delayed function.  Takes an interval in microseconds
            and a function (the "action").  Returns a cancel function.  `timer`
            is a functional approach to JavaScript's native `setTimeout` and
            `clearTimeout`.

            Normally, when the timer reaches zero, the action executes.  But you
            can stop the timer and prevent the action from executing by calling
            the cancel function.  However, once the timer reaches zero, the
            cancel function is rendered useless.
          example:
            code: >-
              # We need an action to put into "timer", but we'll cancel it
              before it runs.

              x = 5

              tooLong = -> x = x * 2

              cancel = timer 10000, tooLong


              # 10 seconds is too long to wait.  Cancel it!!

              cancel()

              assert x == 5   # We kept tooLong from executing.
        - title: sleep
          description: >-
            Perform a non-blocking wait before resuming execution.  Takes a
            duration in milliseconds.  Returns a promise that resolves after the
            given duration, resuming execution.  Because `sleep` non-blocking,
            other actions may take place while the generator that contains
            `sleep` is idle.
          example:
            code: |-
              # Provide a containing generator for the sleep calls.
              call ->
                startTime = Date.now()
                yield sleep 100
                duration = Date.now() - startTime
                assert duration > 50  # Without "sleep", this would take fractions of a millisecond.
        - title: times
          description: >-
            Run a function N times.  Takes a function and the number of times
            you'd like it to run.  Returns an array containing the result of
            each function call.  `times` is curried.
          example:
            code: >-
              x = 2

              square = -> x = x ** 2


              result = times square, 5

              assert.deepEqual result, [ 4, 16, 256, 65536, 4294967296 ] # That
              escalated quickly!!
        - title: benchmark
          description: >-
            Determine the execution time of a function.  Takes a function.
            Returns the time it took to complete in milliseconds.  This is a
            great little function for monitoring performance within your code.
            You can even use this in conjunction with `times` to benchmark a
            function over N repetitions.
          example:
            code: |-
              # Simple function that just burns cycles.
              useless = ->
                for i in [0...1000000]
                  y = 1 + i

              single = benchmark useless                 # Got around 30ms
              multiple = benchmark -> times(useless, 5)  # Got around 500ms

              assert 0 < single < multiple
        - title: empty
          description: >+
            Determine if a data structure contains no value.  Takes a JavaScript
            data structure.  Returns `true` if it contains "no value".



            For arrays and strings, this means that its length is zero.



            For an object, it means that `keys` returns an array of length zero.



            For any other value, it will return true unless it's falsey.


          example:
            code: |-
              assert empty( [] )        == true
              assert empty( "" )        == true
              assert empty( {} )        == true
              assert empty( null )      == true
              assert empty( undefined ) == true

              assert empty( 1 )     == false
              assert empty( [1] )   == false
              assert empty( "abc" ) == false
              assert empty( a: 0 )  == false
              assert empty( true )  == false
              assert empty( false ) == false
        - title: length
          description: >-
            Return the length property of an object.  Takes a JavaScript data
            structure.  Returns the value of the length property, if it exists.
            If the length propery does not exist, an error is thrown.

            Working with lengths crops up so frequently, this function is
            included to better integrate it into functional programming.  We
            *were* tempted to add a variant for objects, but innumerable
            properties would yield potentially surprising results. Instead, just
            use `length keys object`, which is still much more readable than
            `Object.keys(foo).length`.  And, if you're just comparing to zero,
            use `empty`, which works on all data structures, including objects.
          example:
            code: |-
              assert length([]) == 0
              assert length([1]) == 1
              assert length([1, 2]) == 2
              assert length([1, 2, 3]) == 3

              assert length("") == 0
              assert length("p") == 1
              assert length("pan") == 3
              assert length("panda") == 5
        - title: deepEqual
          description: >-
            Assess the equality of two data structures, and go beyond
            superficial comparison.  Takes two JavaScript data structures.
            Returns `true` if they are equal or `false` if they are not.

            JavaScript possesses the comparison operator `===`, which works for
            simple data structures, but fails for arrays and differently shaped
            objects.  `deepEqual` does the extra computation to determine if two
            values are truely equal.
          example:
            code: >-
              a = [1, 2, 3, 4, 5]

              b = [1, 2, 3, 4, 5]

              assert (a == b) == false  # Really, JavaScript?  The comparison
              operator failed us.

              assert deepEqual a, b     # deepEqual saves the day.


              a =
                foo: 1
                bar: 2
                baz: 3

              b =
                bar: 2
                foo: 1
                baz: 3

              assert (a == b) == false  # The comparison operator failed us.

              assert deepEqual a, b     # Again, deepEqual saves the day.
- title: Process
  description: ''
  content:
    - title: Process Functions
      description: ''
      content:
        - title: abort
          description: >-
            End the current process.  Takes an optional message to output.
            Exits with status code `-1`.
          example:
            code: |-
              console.log "You see this message."

              abort "Cap'n she can't hold any longer!"
              console.log "This will never be seen."
        - title: shell
          description: >-
            Asynchronously execute a shell command. Takes a string containing a
            shell command.  Returns a promise that either *resolves* to a result
            object or *rejects* with an error.  The result object contains the
            properties `stdout` and `stderr`, the final results piped to the
            shell's Standard Output and Standard Error, respectively.

            `shell` makes use of the[ NodeJS `child_process` API][shell-0] to
            handle the system call separately and asynchronously.  Your
            JavaScript execution enters a non-blocking wait until the child
            process ends, and you have no access to the output until `shell`
            resolves.  Additionally, `shell` is based on [NodeJS's `exec`
            subcommand][shell-1], which returns a buffer of limited size (200
            kB).  If your shell command is long-running or returns a large
            amount of data it could trigger a maxBuffer exceeded error.  For
            these reasons, `shell` should only be used for short-lived processes
            that don't return much data.
          example:
            code: >-
              # Assume that we're sitting in a directory with this structure:

              # index.coffee

              # data/

              #   panda.md

              #   bamboo.md


              {stdout} = yield shell "ls #{__dirname}/data"


              # Remember that we get a string back from shell.  ls returns a
              newline delimited

              # list of files, so we can parse the output string on that.

              files = stdout.split "\n"

              assert.deepEqual files, [ 'panda.md', 'bamboo.md', '' ]
- title: File System
  description: ''
  content:
    - title: File System Functions
      description: ''
      content:
        - title: read
          description: >-
            Asynchronously read from a data source.  `read` is an overloaded
            function that operates on files and streams.  In both cases, `read`
            returns a promise that either *resolves* to a result or *rejects*
            with an error. Please see the applicable section below to see the
            respective inputs and outputs.

            **Files**

            Takes a file path and an optional string encoding.    The result is
            a promise resolving to a JavaScript `String` of the binary file's
            contents, encoded as specified.  `read` will not resolve until the
            entire file has been processed.  Until that time, you will not be
            able to access the result value.

            By default, `read` uses UTF-8 encoding on the binary data it finds.
            [NodeJS supports other encodings][read-0], including `hex`,
            `base64`, `ascii`, and `utf16le` (aka `ucs2`).

            Additionally, you may retrieve a raw `Buffer` of a file's contents
            by passing `null`, `undefined`, `binary`, or  `buffer` as the second
            argument.
          example:
            code: >-
              # Assume "stream" is a readable stream containing UTF-8 encoded
              data.

              a = yield read stream

              assert a == "Pandas love bamboo."


              # Assume "stream64" is a readable stream containing base64 encoded
              data.

              b = yield read stream64, "base64"

              assert b == "Pandas love bamboo."


              c = yield read stream, "buffer"

              assert.deepEqual c, new Buffer("Pandas love bamboo.")
        - title: write
          description: >-
            Asynchronously write a UTF-8 string or data buffer to a file.  Takes
            a target path and string (or buffer) to be written.  Returns a
            promise that either *resolves* if the write is successful and
            complete or *rejects* with an error.  The resolved return value is
            `undefined`.  `write` will overwrite a file if one already exists at
            the target path.
          example:
            code: |-
              # Store something unique in a file.
              currentTime = Date.now().toString()
              yield write "#{__dirname}/time.txt", currentTime

              # Read back the data and see if it worked.
              value = yield read "#{__dirname}/time.txt"
              assert value == currentTime
        - title: stat
          description: >-
            Asynchronously get the stat object for a file.  Takes a path.
            Returns promise that either *resolves* to a result object or
            *rejects* with an error.  The result object's properties match
            Unix's stat output for a file.
          example:
            code: >-
              # Assume that we're in a directory that has this target file.

              result = yield stat "#{__dirname}/lines.txt"


              # Grab the keys of the result and compare them to the expected
              properties.

              resultKeys = keys result

              expectedKeys = [ 'dev', 'mode', 'nlink', 'uid', 'gid', 'rdev',
              'blksize',
                'ino', 'size', 'blocks', 'atime', 'mtime', 'ctime', 'birthtime' ]

              assert.deepEqual resultKeys, expectedKeys
        - title: exists
          description: >-
            Asynchronously check to see if a file exists.  Takes a path.
            Returns a promise that either *resolves* to a result or *rejects*
            with an error.  The result is a boolean, `true` if the file exists,
            `false` if it does not.
          example:
            code: >-
              # Assume that we're in a directory that has the first file, but
              not the second.

              a = yield exists "#{__dirname}/lines.txt"

              b = yield exists "#{__dirname}/does-not-exist"


              assert a == true

              assert b == false
        - title: readDir / readdir
          description: >-
            Asynchronously retrieve the local filenames within a directory.
            Aliased as `readdir`.  Takes a path.  Returns promise that either
            *resolves* with a result or *rejects* with an error.  A successful
            result is an array of localized filenames at the target path.
            `readDir` does not discriminate between files and directories, so
            both will appear in the result array.
        - title: ls
          description: >-
            Asynchronously retrieve absolute pathnames for a directory's
            contents.  Takes a target path.  Returns a promise that either
            *resolves* with a result or *rejects* with an error.  A successful
            result is an array of absolute filenames at the target path.  `ls`
            does not discriminate between files and directories, so both will
            appear in the result array.
          example:
            code: |-
              # Assume we're in a directory with the following tree:
              # app/
              #   index.coffee
              #   index.html
              # index.coffee
              # index.css
              # index.html

              files = yield ls __dirname
              expectedValues = [
                "#{__dirname}/app"
                "#{__dirname}/index.coffee"
                "#{__dirname}/index.css"
                "#{__dirname}/index.html"
              ]

              # Notice how the returned files and directory are alphabetized.
              assert.deepEqual files, expectedValues
        - title: lsR / lsr
          description: >-
            Asynchronously retrieve the absolute pathnames for a directory's
            contents, including a recursive search through sub-directories.
            Takes a target path.  Returns a promise that either *resolves* with
            a result or *rejects* with an error.   A successful result is an
            array of absolute paths.  `lsR` operates recursively and will return
            *every* file within the filesystem tree under the target path.
          example:
            code: >-
              # Assume we're in a directory with the following tree:

              # app/

              #   index.coffee

              #   index.html

              # index.coffee

              # index.css

              # index.html


              files = yield lsR __dirname

              expectedValues = [
                "#{__dirname}/app/index.coffee"
                "#{__dirname}/app/index.html"
                "#{__dirname}/index.coffee"
                "#{__dirname}/index.css"
                "#{__dirname}/index.html"
              ]


              # Notice how the returned filenames are alphabetized, including
              within sub-directories.

              assert.deepEqual files, expectedValues
        - title: glob
          description: >-
            Asynchronously glob on a directory's contents.  Takes a glob pattern
            and a target path.  Returns a promise that either *resolves* with a
            result or *rejects* with an error.   A successful result is an array
            of absolute *file* paths.

            A glob is a shell pattern that allows you to target multiple
            filenames that match a string with the glob "wildcard" character.
            `glob` only matches on absolute paths, so you need the "Globstar"
            operator (`**`), which matches any parent directory, if you pass in
            a non-absolute path.  However, use with caution because `glob`
            recursively searches sub-directories for matches.

            `glob` discriminates between files and directories and only returns
            matches on files.  If `glob` finds no matching files, an empty array
            is returned.
          example:
            code: >-
              # Assume we're in a directory with the following tree:

              # app/

              #   index.coffee

              #   index.html

              # index.coffee

              # index.css

              # index.html


              files = yield glob "#{__dirname}/*.coffee", __dirname

              expectedValues = [
                "#{__dirname}/index.coffee"
              ]

              assert.deepEqual files, expectedValues


              # With the Globstar, you get any file within the tree that
              matches.

              files = yield glob "**/*.coffee", __dirname

              expectedValues = [
                "#{__dirname}/app/index.coffee"
                "#{__dirname}/index.coffee"
              ]

              assert.deepEqual files, expectedValues


              # Match for everything (files only) in the top-level directory.

              files = yield glob "#{dirname}/*", __dirname

              expectedValues = [
                "#{__dirname}/index.coffee"
                "#{__dirname}/index.css"
                "#{__dirname}/index.html"
              ]

              assert.deepEqual files, expectedValues



              # Match everything, equivalent to "lsR".

              files = yield glob "**/*", __dirname

              expectedValues = [
                "#{dir}/app/index.coffee"
                "#{dir}/app/index.html"
                "#{dir}/index.coffee"
                "#{dir}/index.css"
                "#{dir}/index.html"]
              assert.deepEqual files, expectedValues


              # No matches.

              files = yield glob "**/signup*", dir

              expectedValues = []

              assert.deepEqual files, expectedValues
        - title: chDir / chdir
          description: >-
            Change your working directory.  Aliased as `chdir`.  Takes a path
            and an optional function.   See below for possible results:

            **Without Optional Function**

            When only passed a path, `chdir` returns a function that will
            restore the original working directory when called.

            **With Optional Function**

            When passed a function, `chdir` executes the function.  The working
            directory is altered for the duration of execution and restored when
            the function returns.  **IMPORTANT:** Do not rely on the automatic
            restoration feature when using asynchronous functions, since another
            function may also change the current directory.
          example:
            code: >-
              # Assume we're in a directory with sub-directory "app".  Store the
              original cwd.

              cwd = process.cwd()


              # We can change the working directory.

              goBack = chdir "#{__dirname}/app"

              assert process.cwd() == "#{__dirname}/app"


              # Now, restore the working directory.

              goBack()

              assert process.cwd() == cwd


              # Using chdir with a function results in no change after
              executing.

              f = -> "foobar"

              chdir "#{__dirname}/app", f

              assert process.cwd() == cwd
        - title: mv
          description: >-
            Asynchronously move a file.  Takes a file's path and a destination
            path.  Returns a promise that either resolves on success or rejects
            with an error.  Execution enters a non-blocking wait until the move
            is complete.
          example:
            code: >-
              # Assume we're in a directory with a file "first", and that it
              reads:

              # "Pandas love bamboo."


              yield mv "#{__dirname}/first", "#{__dirname}/second"


              # Check that the first file is gone.

              assert (yield exist "#{__dirname}/first") == false


              # Check that the data moved to the second file.

              data = yield read "#{__dirname}/second"

              assert newData == "Pandas love bamboo."
        - title: cp
          description: >-
            Asynchronously copy a file.  Takes a file's path and a destination
            path.  Returns a promise that either resolves on success or rejects
            with an error.  Execution enters a non-blocking wait until the copy
            is complete.
          example:
            code: >-
              # Assume we're in a directory with a file "first", and that it
              reads:

              # "Pandas love bamboo."


              yield cp "#{__dirname}/first", "#{__dirname}/second"


              # Check that the first file is still there.

              assert (yield exist "#{__dirname}/first") == true


              # Check that the data was copied to the second file.

              data = yield read "#{__dirname}/second"

              assert newData == "Pandas love bamboo."
        - title: rm
          description: >-
            Asynchronously remove a file.  Takes a file's path.  Returns a
            promise that either resolves on success or rejects with an error.
            Execution enters a non-blocking wait until the deletion is complete.
          example:
            code: |-
              # Assume we're in a directory with a file "test".
              yield rm "#{__dirname}/test"

              # Check that the file is gone.
              assert (yield exist "#{__dirname}/test") == false
        - title: rmDir / rmdir
          description: >-
            Asynchronously remove a directory.  Takes a directory's path.
            Returns a promise that either resolves on success or rejects with an
            error.  `rmDir` will fail if the target directory is not empty.
            Execution enters a non-blocking wait until the deletion is complete.
          example:
            code: |-
              # Assume we're in a directory with a directory "test".
              yield rmDir "#{__dirname}/test"

              # Check that the directory is gone.
              assert (yield exist "#{__dirname}/test") == false
        - title: mkDir / mkdir
          description: >-
            Asynchronously create a directory.  Aliased as `mkdir`.  Takes a
            [mode][mkDir-0] (octal value only) and a path.  Returns a promise
            that either resolves on success or rejects with an error.  Assumes
            any intermediate directories in the path already exist.  Execution
            enters a non-blocking wait until the creation is complete.
        - title: mkDirP / mkdirp
          description: >-
            Asynchronously create a directory and any intermediaries.  Aliased
            as `mkdirp`.  Takes a [mode][mkDirP-0] (octal value only) and a
            path.  Returns a promise that either resolves on success or rejects
            with an error.  Will create the specified directory and any
            intermediate directories, as necessary. Execution enters a
            non-blocking wait until the creation is complete.
        - title: isDirectory
          description: >-
            Asynchronously discriminate between files and directories.  Takes a
            path.  Returns a promise that either resolves on success or rejects
            with an error.  Success is a boolean, `true` if the path names a
            directory, `false` if it does not.
        - title: isFile
          description: >-
            Asynchronously discriminate between files and directories.  Takes a
            path.  Returns a promise that either resolves on success or rejects
            with an error.  Success is a boolean, `true` if the path names a
            file, `false` if it does not.
- title: Multi-methods
  description: >-
    [Multi-methods][1] are polymorphic functions on their arguments. Methods in
    JavaScript objects dispatch based only on the (implicit first argument,
    which is the) object itself. Multi-methods provide a more functional and
    flexible approach.

    Fairmont's multi-method dispatch is based on a predicate provided for each
    argument. The first implementation for which each of the predicates returns
    true when given the corresponding argument is chosen.

    Variadic functions can be handled by passing a variadic predicate (that is,
    a function whose length is 0), will be passed the remaining arguments. Any
    predicates following a variadic predicate will fail.

    Method definitions are considered based on the order in which they were
    declared. The last definition is considered first. The first definition is
    considered last. More general definitions should thus be defined first and
    specializations later.
  content:
    - title: Method
      description: ''
      content:
        - title: Method.create
          description: >-
            The `create` function defines a new multimethod, taking an optional
            description of the method. This can be accessed via the
            `description` property of the method.
          example:
            code: >-
              Method.create multiply, description: "Multiply two values
              together"
        - title: Method.define
          description: >-
            The `define` function adds an entry into the dispatch table. It
            takes the method, the signature, and the definition (implementation)
            as arguments.
          example:
            code: >-
              Method.define multiply, isNumber, isNumber, (x,y) -> x * y

              Method.define multiply, isArray, isNumber, (v, n) -> n * v for x
              in v
        - title: Method.lookup
          description: >-
            The 'lookup' function calls the 'dispatch' function, which is
            described above. This allows you to select a function without
            invoking it.
          example:
            code: |-
              f = Method.lookup multiply, [7, 5]
              assert (f 7, 5) == 35
